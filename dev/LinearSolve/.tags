!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!Julia	Y,unknown	/name defined in other modules/
!_TAG_KIND_DESCRIPTION!Julia	c,constant	/Constants/
!_TAG_KIND_DESCRIPTION!Julia	f,function	/Functions/
!_TAG_KIND_DESCRIPTION!Julia	g,field	/Fields/
!_TAG_KIND_DESCRIPTION!Julia	m,macro	/Macros/
!_TAG_KIND_DESCRIPTION!Julia	n,module	/Modules/
!_TAG_KIND_DESCRIPTION!Julia	s,struct	/Structures/
!_TAG_KIND_DESCRIPTION!Julia	t,type	/Types/
!_TAG_KIND_DESCRIPTION!Markdown	S,subsection	/level 2 sections/
!_TAG_KIND_DESCRIPTION!Markdown	T,l4subsection	/level 4 sections/
!_TAG_KIND_DESCRIPTION!Markdown	c,chapter	/chapters/
!_TAG_KIND_DESCRIPTION!Markdown	h,hashtag	/hashtags/
!_TAG_KIND_DESCRIPTION!Markdown	n,footnote	/footnotes/
!_TAG_KIND_DESCRIPTION!Markdown	s,section	/sections/
!_TAG_KIND_DESCRIPTION!Markdown	t,subsubsection	/level 3 sections/
!_TAG_KIND_DESCRIPTION!Markdown	u,l5subsection	/level 5 sections/
!_TAG_KIND_DESCRIPTION!Yaml	a,anchor	/anchors/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	1.1	/current.age/
!_TAG_PARSER_VERSION!Julia	0.0	/current.age/
!_TAG_PARSER_VERSION!Markdown	1.1	/current.age/
!_TAG_PARSER_VERSION!Yaml	0.0	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/romeo/.julia/dev/LinearSolve/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.2.0	/v6.2.0/
!_TAG_ROLE_DESCRIPTION!Julia!module	imported	/loaded by "import"/
!_TAG_ROLE_DESCRIPTION!Julia!module	namespace	/only some symbols in it are imported/
!_TAG_ROLE_DESCRIPTION!Julia!module	used	/loaded by "using"/
!_TAG_ROLE_DESCRIPTION!Julia!unknown	imported	/loaded by "import"/
!_TAG_ROLE_DESCRIPTION!Julia!unknown	used	/loaded by "using"/
!_TAG_ROLE_DESCRIPTION!Yaml!anchor	alias	/alias/
A	ext/LinearSolveHYPREExt.jl	/^    A::Union{HYPREMatrix, Nothing}$/;"	g	struct:LinearSolveHYPREExt.HYPRECache
A	src/common.jl	/^    A::TA$/;"	g	struct:LinearCache
A	src/simplegmres.jl	/^    b$/;"	g	struct:SimpleGMRESCache
A	src/simplelu.jl	/^    A::Matrix{T}$/;"	g	struct:LUSolver
AMD_AGGRESSIVE	src/KLU/wrappers.jl	/^const AMD_AGGRESSIVE = 1$/;"	c
AMD_CONTROL	src/KLU/wrappers.jl	/^const AMD_CONTROL = 5$/;"	c
AMD_DATE	src/KLU/wrappers.jl	/^const AMD_DATE = "Sept 18, 2023"$/;"	c
AMD_DEFAULT_AGGRESSIVE	src/KLU/wrappers.jl	/^const AMD_DEFAULT_AGGRESSIVE = 1$/;"	c
AMD_DEFAULT_DENSE	src/KLU/wrappers.jl	/^const AMD_DEFAULT_DENSE = 10.0$/;"	c
AMD_DENSE	src/KLU/wrappers.jl	/^const AMD_DENSE = 0$/;"	c
AMD_DMAX	src/KLU/wrappers.jl	/^const AMD_DMAX = 13$/;"	c
AMD_INFO	src/KLU/wrappers.jl	/^const AMD_INFO = 20$/;"	c
AMD_INVALID	src/KLU/wrappers.jl	/^const AMD_INVALID = -2$/;"	c
AMD_LNZ	src/KLU/wrappers.jl	/^const AMD_LNZ = 9$/;"	c
AMD_MAIN_VERSION	src/KLU/wrappers.jl	/^const AMD_MAIN_VERSION = 3$/;"	c
AMD_MEMORY	src/KLU/wrappers.jl	/^const AMD_MEMORY = 7$/;"	c
AMD_N	src/KLU/wrappers.jl	/^const AMD_N = 1$/;"	c
AMD_NCMPA	src/KLU/wrappers.jl	/^const AMD_NCMPA = 8$/;"	c
AMD_NDENSE	src/KLU/wrappers.jl	/^const AMD_NDENSE = 6$/;"	c
AMD_NDIV	src/KLU/wrappers.jl	/^const AMD_NDIV = 10$/;"	c
AMD_NMULTSUBS_LDL	src/KLU/wrappers.jl	/^const AMD_NMULTSUBS_LDL = 11$/;"	c
AMD_NMULTSUBS_LU	src/KLU/wrappers.jl	/^const AMD_NMULTSUBS_LU = 12$/;"	c
AMD_NZ	src/KLU/wrappers.jl	/^const AMD_NZ = 2$/;"	c
AMD_NZDIAG	src/KLU/wrappers.jl	/^const AMD_NZDIAG = 4$/;"	c
AMD_NZ_A_PLUS_AT	src/KLU/wrappers.jl	/^const AMD_NZ_A_PLUS_AT = 5$/;"	c
AMD_OK	src/KLU/wrappers.jl	/^const AMD_OK = 0$/;"	c
AMD_OK_BUT_JUMBLED	src/KLU/wrappers.jl	/^const AMD_OK_BUT_JUMBLED = 1$/;"	c
AMD_OUT_OF_MEMORY	src/KLU/wrappers.jl	/^const AMD_OUT_OF_MEMORY = -1$/;"	c
AMD_STATUS	src/KLU/wrappers.jl	/^const AMD_STATUS = 0$/;"	c
AMD_SUBSUB_VERSION	src/KLU/wrappers.jl	/^const AMD_SUBSUB_VERSION = 1$/;"	c
AMD_SUB_VERSION	src/KLU/wrappers.jl	/^const AMD_SUB_VERSION = 2$/;"	c
AMD_SYMMETRY	src/KLU/wrappers.jl	/^const AMD_SYMMETRY = 3$/;"	c
AMD_VERSION	src/KLU/wrappers.jl	/^const AMD_VERSION = AMD_VERSION_CODE(AMD_MAIN_VERSION, AMD_SUB_VERSION)$/;"	c
AMD_VERSION_CODE	src/KLU/wrappers.jl	/^AMD_VERSION_CODE(main, sub) = main * 1000 + sub$/;"	f
AbstractDenseFactorization	src/LinearSolve.jl	/^abstract type AbstractDenseFactorization <: AbstractFactorization end$/;"	t	module:LinearSolve
AbstractFactorization	src/LinearSolve.jl	/^abstract type AbstractFactorization <: SciMLLinearSolveAlgorithm end$/;"	t	module:LinearSolve
AbstractKLUFactorization	src/KLU/klu.jl	/^abstract type AbstractKLUFactorization{Tv, Ti} <: LinearAlgebra.Factorization{Tv} end$/;"	t	module:KLU
AbstractKrylovSubspaceMethod	src/LinearSolve.jl	/^abstract type AbstractKrylovSubspaceMethod <: SciMLLinearSolveAlgorithm end$/;"	t	module:LinearSolve
AbstractSolveFunction	src/LinearSolve.jl	/^abstract type AbstractSolveFunction <: SciMLLinearSolveAlgorithm end$/;"	t	module:LinearSolve
AbstractSparseFactorization	src/LinearSolve.jl	/^abstract type AbstractSparseFactorization <: AbstractFactorization end$/;"	t	module:LinearSolve
Accelerating your Linear Solves	docs/src/tutorials/accelerating_choices.md	/^# Accelerating your Linear Solves$/;"	c
AdjointFact	src/KLU/klu.jl	/^const AdjointFact = isdefined(LinearAlgebra, :AdjointFactorization) ?$/;"	c	module:KLU
AppleAccelerate.jl	docs/src/solvers/solvers.md	/^### AppleAccelerate.jl$/;"	S	section:[Linear System Solvers](@id linearsystemsolvers)""Full List of Methods
AppleAccelerateLUFactorization	src/appleaccelerate.jl	/^struct AppleAccelerateLUFactorization <: AbstractFactorization end$/;"	s
AppleAccelerateLUFactorization	src/default.jl	/^    AppleAccelerateLUFactorization::T17$/;"	g	struct:DefaultLinearSolverInit
BLASELTYPES	src/LinearSolve.jl	/^const BLASELTYPES = Union{Float32, Float64, ComplexF32, ComplexF64}$/;"	c
BTF_DATE	src/KLU/wrappers.jl	/^const BTF_DATE = "Sept 18, 2023"$/;"	c
BTF_MAIN_VERSION	src/KLU/wrappers.jl	/^const BTF_MAIN_VERSION = 2$/;"	c
BTF_SUBSUB_VERSION	src/KLU/wrappers.jl	/^const BTF_SUBSUB_VERSION = 1$/;"	c
BTF_SUB_VERSION	src/KLU/wrappers.jl	/^const BTF_SUB_VERSION = 2$/;"	c
BTF_VERSION	src/KLU/wrappers.jl	/^const BTF_VERSION = BTF_VERSION_CODE(BTF_MAIN_VERSION, BTF_SUB_VERSION)$/;"	c
BTF_VERSION_CODE	src/KLU/wrappers.jl	/^BTF_VERSION_CODE(main, sub) = main * 1000 + sub$/;"	f
Base.LinearAlgebra	docs/src/solvers/solvers.md	/^### Base.LinearAlgebra$/;"	S	section:[Linear System Solvers](@id linearsystemsolvers)""Full List of Methods
BunchKaufmanFactorization	src/default.jl	/^    BunchKaufmanFactorization::T12$/;"	g	struct:DefaultLinearSolverInit
BunchKaufmanFactorization	src/factorization.jl	/^Base.@kwdef struct BunchKaufmanFactorization <: AbstractDenseFactorization$/;"	s
CHOLMODFactorization	src/default.jl	/^    CHOLMODFactorization::T13$/;"	g	struct:DefaultLinearSolverInit
CHOLMODFactorization	src/factorization.jl	/^Base.@kwdef struct CHOLMODFactorization{T} <: AbstractSparseFactorization$/;"	s
COLAMD_AGGRESSIVE	src/KLU/wrappers.jl	/^const COLAMD_AGGRESSIVE = 2$/;"	c
COLAMD_DATE	src/KLU/wrappers.jl	/^const COLAMD_DATE = "Sept 18, 2023"$/;"	c
COLAMD_DEFRAG_COUNT	src/KLU/wrappers.jl	/^const COLAMD_DEFRAG_COUNT = 2$/;"	c
COLAMD_DENSE_COL	src/KLU/wrappers.jl	/^const COLAMD_DENSE_COL = 1$/;"	c
COLAMD_DENSE_ROW	src/KLU/wrappers.jl	/^const COLAMD_DENSE_ROW = 0$/;"	c
COLAMD_ERROR_A_not_present	src/KLU/wrappers.jl	/^const COLAMD_ERROR_A_not_present = -1$/;"	c
COLAMD_ERROR_A_too_small	src/KLU/wrappers.jl	/^const COLAMD_ERROR_A_too_small = -7$/;"	c
COLAMD_ERROR_col_length_negative	src/KLU/wrappers.jl	/^const COLAMD_ERROR_col_length_negative = -8$/;"	c
COLAMD_ERROR_internal_error	src/KLU/wrappers.jl	/^const COLAMD_ERROR_internal_error = -999$/;"	c
COLAMD_ERROR_ncol_negative	src/KLU/wrappers.jl	/^const COLAMD_ERROR_ncol_negative = -4$/;"	c
COLAMD_ERROR_nnz_negative	src/KLU/wrappers.jl	/^const COLAMD_ERROR_nnz_negative = -5$/;"	c
COLAMD_ERROR_nrow_negative	src/KLU/wrappers.jl	/^const COLAMD_ERROR_nrow_negative = -3$/;"	c
COLAMD_ERROR_out_of_memory	src/KLU/wrappers.jl	/^const COLAMD_ERROR_out_of_memory = -10$/;"	c
COLAMD_ERROR_p0_nonzero	src/KLU/wrappers.jl	/^const COLAMD_ERROR_p0_nonzero = -6$/;"	c
COLAMD_ERROR_p_not_present	src/KLU/wrappers.jl	/^const COLAMD_ERROR_p_not_present = -2$/;"	c
COLAMD_ERROR_row_index_out_of_bounds	src/KLU/wrappers.jl	/^const COLAMD_ERROR_row_index_out_of_bounds = -9$/;"	c
COLAMD_INFO1	src/KLU/wrappers.jl	/^const COLAMD_INFO1 = 4$/;"	c
COLAMD_INFO2	src/KLU/wrappers.jl	/^const COLAMD_INFO2 = 5$/;"	c
COLAMD_INFO3	src/KLU/wrappers.jl	/^const COLAMD_INFO3 = 6$/;"	c
COLAMD_KNOBS	src/KLU/wrappers.jl	/^const COLAMD_KNOBS = 20$/;"	c
COLAMD_MAIN_VERSION	src/KLU/wrappers.jl	/^const COLAMD_MAIN_VERSION = 3$/;"	c
COLAMD_OK	src/KLU/wrappers.jl	/^const COLAMD_OK = 0$/;"	c
COLAMD_OK_BUT_JUMBLED	src/KLU/wrappers.jl	/^const COLAMD_OK_BUT_JUMBLED = 1$/;"	c
COLAMD_STATS	src/KLU/wrappers.jl	/^const COLAMD_STATS = 20$/;"	c
COLAMD_STATUS	src/KLU/wrappers.jl	/^const COLAMD_STATUS = 3$/;"	c
COLAMD_SUBSUB_VERSION	src/KLU/wrappers.jl	/^const COLAMD_SUBSUB_VERSION = 1$/;"	c
COLAMD_SUB_VERSION	src/KLU/wrappers.jl	/^const COLAMD_SUB_VERSION = 2$/;"	c
COLAMD_VERSION	src/KLU/wrappers.jl	/^const COLAMD_VERSION = COLAMD_VERSION_CODE(COLAMD_MAIN_VERSION, COLAMD_SUB_VERSION)$/;"	c
COLAMD_VERSION_CODE	src/KLU/wrappers.jl	/^COLAMD_VERSION_CODE(main, sub) = main * 1000 + sub$/;"	f
COMM_SOLVERS	ext/LinearSolveHYPREExt.jl	/^const COMM_SOLVERS = Union{HYPRE.BiCGSTAB, HYPRE.FlexGMRES, HYPRE.GMRES, HYPRE.ParaSails,$/;"	c
CRC	src/LinearSolve.jl	/^const CRC = ChainRulesCore$/;"	c	module:LinearSolve
CUDA.jl	docs/src/solvers/solvers.md	/^### CUDA.jl$/;"	S	section:[Linear System Solvers](@id linearsystemsolvers)""Full List of Methods
CholeskyFactorization	src/default.jl	/^    CholeskyFactorization::T15$/;"	g	struct:DefaultLinearSolverInit
CholeskyFactorization	src/factorization.jl	/^function CholeskyFactorization(; pivot = nothing, tol = 0.0, shift = 0.0, perm = nothing)$/;"	f
CholeskyFactorization	src/factorization.jl	/^struct CholeskyFactorization{P, P2} <: AbstractDenseFactorization$/;"	s
Common Solver Options (Keyword Arguments for Solve)	docs/src/basics/common_solver_opts.md	/^# Common Solver Options (Keyword Arguments for Solve)$/;"	c
ComposePreconditioner	src/preconditioners.jl	/^struct ComposePreconditioner{Ti, To}$/;"	s
Condition Number Specifications	docs/src/basics/OperatorAssumptions.md	/^## Condition Number Specifications$/;"	s	chapter:[Linear Solve Operator Assumptions](@id assumptions)
Contributing	docs/src/index.md	/^## Contributing$/;"	s	chapter:LinearSolve.jl: High-Performance Unified Linear Solvers
CudaOffloadFactorization	src/extension_algs.jl	/^    function CudaOffloadFactorization()$/;"	f	struct:CudaOffloadFactorization
CudaOffloadFactorization	src/extension_algs.jl	/^struct CudaOffloadFactorization <: LinearSolve.AbstractFactorization$/;"	s
Curated List of Pre-Defined Preconditioners	docs/src/basics/Preconditioners.md	/^## Curated List of Pre-Defined Preconditioners$/;"	s	chapter:[Preconditioners](@id prec)
DEFAULT_PRECS	src/common.jl	/^DEFAULT_PRECS(A, p) = IdentityOperator(size(A)[1]), IdentityOperator(size(A)[2])$/;"	f
DefaultLinearSolver	src/LinearSolve.jl	/^    DefaultLinearSolver(alg; safetyfallback=true) = new(alg,safetyfallback)$/;"	f	struct:LinearSolve.DefaultLinearSolver
DefaultLinearSolver	src/LinearSolve.jl	/^struct DefaultLinearSolver <: SciMLLinearSolveAlgorithm$/;"	s	module:LinearSolve
DefaultLinearSolverInit	src/default.jl	/^mutable struct DefaultLinearSolverInit{T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,$/;"	s
Dense Matrices	docs/src/solvers/solvers.md	/^### Dense Matrices$/;"	S	section:[Linear System Solvers](@id linearsystemsolvers)""Recommended Methods
Developing New Linear Solvers	docs/src/advanced/developing.md	/^# Developing New Linear Solvers$/;"	c
Developing New Linear Solvers with LinearSolve.jl Primitives	docs/src/advanced/developing.md	/^## Developing New Linear Solvers with LinearSolve.jl Primitives$/;"	s	chapter:Developing New Linear Solvers
DiagonalFactorization	src/default.jl	/^    DiagonalFactorization::T3$/;"	g	struct:DefaultLinearSolverInit
DiagonalFactorization	src/factorization.jl	/^struct DiagonalFactorization <: AbstractDenseFactorization end$/;"	s
DirectLdiv!	src/default.jl	/^    DirectLdiv!::T4$/;"	g	struct:DefaultLinearSolverInit
DirectLdiv!	src/solve_function.jl	/^struct DirectLdiv! <: AbstractSolveFunction end$/;"	s
Dual64	test/basictests.jl	/^const Dual64 = ForwardDiff.Dual{Nothing, Float64, 1}$/;"	c
FastLUFactorization	src/extension_algs.jl	/^struct FastLUFactorization <: AbstractDenseFactorization end$/;"	s
FastLapackInterface.jl	docs/src/solvers/solvers.md	/^### FastLapackInterface.jl$/;"	S	section:[Linear System Solvers](@id linearsystemsolvers)""Full List of Methods
FastQRFactorization	src/extension_algs.jl	/^FastQRFactorization() = FastQRFactorization(NoPivot(), 36)$/;"	f
FastQRFactorization	src/extension_algs.jl	/^struct FastQRFactorization{P} <: AbstractDenseFactorization$/;"	s
Frequently Asked Questions	docs/src/basics/FAQ.md	/^# Frequently Asked Questions$/;"	c
Full List of Methods	docs/src/solvers/solvers.md	/^## Full List of Methods$/;"	s	chapter:[Linear System Solvers](@id linearsystemsolvers)
GPU-Accelerated Linear Solving in Julia	docs/src/tutorials/gpu.md	/^# GPU-Accelerated Linear Solving in Julia$/;"	c
GPU-Offloading	docs/src/tutorials/gpu.md	/^## GPU-Offloading$/;"	s	chapter:GPU-Accelerated Linear Solving in Julia
GPUArray Interface	docs/src/tutorials/gpu.md	/^## GPUArray Interface$/;"	s	chapter:GPU-Accelerated Linear Solving in Julia
GROUP	test/runtests.jl	/^const GROUP = get(ENV, "GROUP", "All")$/;"	c
General Controls	docs/src/basics/common_solver_opts.md	/^## General Controls$/;"	s	chapter:Common Solver Options (Keyword Arguments for Solve)
GenericFactorization	src/factorization.jl	/^GenericFactorization(; fact_alg = LinearAlgebra.factorize) = GenericFactorization(fact_alg)$/;"	f
GenericFactorization	src/factorization.jl	/^struct GenericFactorization{F} <: AbstractDenseFactorization$/;"	s
GenericLUFactorization	src/default.jl	/^    GenericLUFactorization::T9$/;"	g	struct:DefaultLinearSolverInit
GenericLUFactorization	src/factorization.jl	/^GenericLUFactorization() = GenericLUFactorization(RowMaximum())$/;"	f
GenericLUFactorization	src/factorization.jl	/^struct GenericLUFactorization{P} <: AbstractDenseFactorization$/;"	s
Getting Started with Solving Linear Systems in Julia	docs/src/tutorials/linear.md	/^# Getting Started with Solving Linear Systems in Julia$/;"	c
HAS_APPLE_ACCELERATE	src/LinearSolve.jl	/^const HAS_APPLE_ACCELERATE = Ref(false)$/;"	c
HAS_EXTENSIONS	test/runtests.jl	/^const HAS_EXTENSIONS = isdefined(Base, :get_extension)$/;"	c
HYPRE.jl	docs/src/solvers/solvers.md	/^### HYPRE.jl$/;"	S	section:[Linear System Solvers](@id linearsystemsolvers)""Full List of Methods
HYPREAlgorithm	src/extension_algs.jl	/^    function HYPREAlgorithm(solver)$/;"	f	struct:HYPREAlgorithm
HYPREAlgorithm	src/extension_algs.jl	/^struct HYPREAlgorithm <: SciMLLinearSolveAlgorithm$/;"	s
HYPRECache	ext/LinearSolveHYPREExt.jl	/^mutable struct HYPRECache$/;"	s	module:LinearSolveHYPREExt
High Level Examples	README.md	/^## High Level Examples$/;"	s	chapter:LinearSolve.jl
How do I use IterativeSolvers solvers with a weighted tolerance vector?	docs/src/basics/FAQ.md	/^## How do I use IterativeSolvers solvers with a weighted tolerance vector?$/;"	s	chapter:Frequently Asked Questions
How is LinearSolve.jl compared to just using normal \\, i.e. A\\b?	docs/src/basics/FAQ.md	/^## How is LinearSolve.jl compared to just using normal \\, i.e. A\\b?$/;"	s	chapter:Frequently Asked Questions
I found a faster algorithm that can be used than what LinearSolve.jl chose?	docs/src/basics/FAQ.md	/^## I found a faster algorithm that can be used than what LinearSolve.jl chose?$/;"	s	chapter:Frequently Asked Questions
I'm seeing some dynamic dispatches in the default algorithm choice, how do I reduce that?	docs/src/basics/FAQ.md	/^## I'm seeing some dynamic dispatches in the default algorithm choice, how do I reduce that?$/;"	s	chapter:Frequently Asked Questions
IS_OPENBLAS	src/LinearSolve.jl	/^const IS_OPENBLAS = Ref(true)$/;"	c
Installation	docs/src/index.md	/^## Installation$/;"	s	chapter:LinearSolve.jl: High-Performance Unified Linear Solvers
InvPreconditioner	src/preconditioners.jl	/^struct InvPreconditioner{T}$/;"	s
Iterative Solver Controls	docs/src/basics/common_solver_opts.md	/^## Iterative Solver Controls$/;"	s	chapter:Common Solver Options (Keyword Arguments for Solve)
IterativeSolvers.jl	docs/src/solvers/solvers.md	/^### IterativeSolvers.jl$/;"	S	section:[Linear System Solvers](@id linearsystemsolvers)""Full List of Methods
IterativeSolversJL	ext/LinearSolveIterativeSolversExt.jl	/^function LinearSolve.IterativeSolversJL(args...;$/;"	f	module:LinearSolve
IterativeSolversJL	src/extension_algs.jl	/^struct IterativeSolversJL{F, I, P, A, K} <: LinearSolve.AbstractKrylovSubspaceMethod$/;"	s
IterativeSolversJL_BICGSTAB	ext/LinearSolveIterativeSolversExt.jl	/^function LinearSolve.IterativeSolversJL_BICGSTAB(args...; kwargs...)$/;"	f	module:LinearSolve
IterativeSolversJL_BICGSTAB	src/extension_algs.jl	/^function IterativeSolversJL_BICGSTAB end$/;"	f
IterativeSolversJL_CG	ext/LinearSolveIterativeSolversExt.jl	/^function LinearSolve.IterativeSolversJL_CG(args...; kwargs...)$/;"	f	module:LinearSolve
IterativeSolversJL_CG	src/extension_algs.jl	/^function IterativeSolversJL_CG end$/;"	f
IterativeSolversJL_GMRES	ext/LinearSolveIterativeSolversExt.jl	/^function LinearSolve.IterativeSolversJL_GMRES(args...; kwargs...)$/;"	f	module:LinearSolve
IterativeSolversJL_GMRES	src/extension_algs.jl	/^function IterativeSolversJL_GMRES end$/;"	f
IterativeSolversJL_IDRS	ext/LinearSolveIterativeSolversExt.jl	/^function LinearSolve.IterativeSolversJL_IDRS(args...; kwargs...)$/;"	f	module:LinearSolve
IterativeSolversJL_IDRS	src/extension_algs.jl	/^function IterativeSolversJL_IDRS end$/;"	f
IterativeSolversJL_MINRES	ext/LinearSolveIterativeSolversExt.jl	/^function LinearSolve.IterativeSolversJL_MINRES(args...; kwargs...)$/;"	f	module:LinearSolve
IterativeSolversJL_MINRES	src/extension_algs.jl	/^function IterativeSolversJL_MINRES end$/;"	f
Iwork	src/KLU/wrappers.jl	/^    Iwork::Ptr{Int32}$/;"	g	struct:klu_numeric
Iwork	src/KLU/wrappers.jl	/^    Iwork::Ptr{Int64}$/;"	g	struct:klu_l_numeric
KLU	src/KLU/klu.jl	/^module KLU$/;"	n
KLUFactorization	src/KLU/klu.jl	/^    function KLUFactorization(n, colptr, rowval, nzval)$/;"	f	struct:KLU.KLUFactorization
KLUFactorization	src/KLU/klu.jl	/^function KLUFactorization(A::SparseMatrixCSC{$/;"	f
KLUFactorization	src/KLU/klu.jl	/^mutable struct KLUFactorization{Tv <: KLUTypes, Ti <: KLUITypes} <:$/;"	s	module:KLU
KLUFactorization	src/default.jl	/^    KLUFactorization::T6$/;"	g	struct:DefaultLinearSolverInit
KLUFactorization	src/factorization.jl	/^Base.@kwdef struct KLUFactorization <: AbstractSparseFactorization$/;"	s
KLUITypes	src/KLU/klu.jl	/^    const KLUITypes = Int32$/;"	c	module:KLU
KLUITypes	src/KLU/klu.jl	/^    const KLUITypes = Union{Int32, Int64}$/;"	c	module:KLU
KLUIndexTypes	src/KLU/klu.jl	/^    const KLUIndexTypes = (:Int32, :Int64)$/;"	c	module:KLU
KLUIndexTypes	src/KLU/klu.jl	/^    const KLUIndexTypes = (:Int32,)$/;"	c	module:KLU
KLUTypes	src/KLU/klu.jl	/^const KLUTypes = Union{Float64, ComplexF64}$/;"	c	module:KLU
KLUValueTypes	src/KLU/klu.jl	/^const KLUValueTypes = (:Float64, :ComplexF64)$/;"	c	module:KLU
KLU_DATE	src/KLU/wrappers.jl	/^const KLU_DATE = "Sept 18, 2023"$/;"	c
KLU_INVALID	src/KLU/wrappers.jl	/^const KLU_INVALID = -3$/;"	c
KLU_MAIN_VERSION	src/KLU/wrappers.jl	/^const KLU_MAIN_VERSION = 2$/;"	c
KLU_OK	src/KLU/wrappers.jl	/^const KLU_OK = 0$/;"	c
KLU_OUT_OF_MEMORY	src/KLU/wrappers.jl	/^const KLU_OUT_OF_MEMORY = -2$/;"	c
KLU_SINGULAR	src/KLU/wrappers.jl	/^const KLU_SINGULAR = 1$/;"	c
KLU_SUBSUB_VERSION	src/KLU/wrappers.jl	/^const KLU_SUBSUB_VERSION = 1$/;"	c
KLU_SUB_VERSION	src/KLU/wrappers.jl	/^const KLU_SUB_VERSION = 2$/;"	c
KLU_TOO_LARGE	src/KLU/wrappers.jl	/^const KLU_TOO_LARGE = -4$/;"	c
KLU_VERSION	src/KLU/wrappers.jl	/^const KLU_VERSION = KLU_VERSION_CODE(KLU_MAIN_VERSION, KLU_SUB_VERSION)$/;"	c
KLU_VERSION_CODE	src/KLU/wrappers.jl	/^KLU_VERSION_CODE(main, sub) = main * 1000 + sub$/;"	f
Krylov.jl	docs/src/solvers/solvers.md	/^### Krylov.jl$/;"	S	section:[Linear System Solvers](@id linearsystemsolvers)""Full List of Methods
KrylovAlg	src/extension_algs.jl	/^    KrylovAlg::F$/;"	g	struct:KrylovKitJL
KrylovAlg	src/iterative_wrappers.jl	/^    KrylovAlg::F$/;"	g	struct:KrylovJL
KrylovJL	src/iterative_wrappers.jl	/^function KrylovJL(args...; KrylovAlg = Krylov.gmres!,$/;"	f
KrylovJL	src/iterative_wrappers.jl	/^struct KrylovJL{F, I, P, A, K} <: AbstractKrylovSubspaceMethod$/;"	s
KrylovJL_BICGSTAB	src/iterative_wrappers.jl	/^function KrylovJL_BICGSTAB(args...; kwargs...)$/;"	f
KrylovJL_CG	src/iterative_wrappers.jl	/^function KrylovJL_CG(args...; kwargs...)$/;"	f
KrylovJL_CRAIGMR	src/default.jl	/^    KrylovJL_CRAIGMR::T20$/;"	g	struct:DefaultLinearSolverInit
KrylovJL_CRAIGMR	src/iterative_wrappers.jl	/^function KrylovJL_CRAIGMR(args...; kwargs...)$/;"	f
KrylovJL_GMRES	src/default.jl	/^    KrylovJL_GMRES::T8$/;"	g	struct:DefaultLinearSolverInit
KrylovJL_GMRES	src/iterative_wrappers.jl	/^function KrylovJL_GMRES(args...; kwargs...)$/;"	f
KrylovJL_LSMR	src/default.jl	/^    KrylovJL_LSMR::T21$/;"	g	struct:DefaultLinearSolverInit
KrylovJL_LSMR	src/iterative_wrappers.jl	/^function KrylovJL_LSMR(args...; kwargs...)$/;"	f
KrylovJL_MINARES	src/iterative_wrappers.jl	/^function KrylovJL_MINARES(args...; kwargs...)$/;"	f
KrylovJL_MINRES	src/iterative_wrappers.jl	/^function KrylovJL_MINRES(args...; kwargs...)$/;"	f
KrylovKit.jl	docs/src/solvers/solvers.md	/^### KrylovKit.jl$/;"	S	section:[Linear System Solvers](@id linearsystemsolvers)""Full List of Methods
KrylovKitJL	ext/LinearSolveKrylovKitExt.jl	/^function LinearSolve.KrylovKitJL(args...;$/;"	f	module:LinearSolve
KrylovKitJL	src/extension_algs.jl	/^struct KrylovKitJL{F, I, P, A, K} <: LinearSolve.AbstractKrylovSubspaceMethod$/;"	s
KrylovKitJL_CG	ext/LinearSolveKrylovKitExt.jl	/^function LinearSolve.KrylovKitJL_CG(args...; kwargs...)$/;"	f	module:LinearSolve
KrylovKitJL_CG	src/extension_algs.jl	/^function KrylovKitJL_CG end$/;"	f
KrylovKitJL_GMRES	ext/LinearSolveKrylovKitExt.jl	/^function LinearSolve.KrylovKitJL_GMRES(args...; kwargs...)$/;"	f	module:LinearSolve
KrylovKitJL_GMRES	src/extension_algs.jl	/^function KrylovKitJL_GMRES end$/;"	f
LDLtFactorization	src/default.jl	/^    LDLtFactorization::T11$/;"	g	struct:DefaultLinearSolverInit
LDLtFactorization	src/factorization.jl	/^function LDLtFactorization(shift = 0.0, perm = nothing)$/;"	f
LDLtFactorization	src/factorization.jl	/^struct LDLtFactorization{T} <: AbstractDenseFactorization$/;"	s
LONGER_TESTS	test/runtests.jl	/^const LONGER_TESTS = false$/;"	c
LUFactorization	src/default.jl	/^    LUFactorization::T1$/;"	g	struct:DefaultLinearSolverInit
LUFactorization	src/factorization.jl	/^Base.@kwdef struct LUFactorization{P} <: AbstractDenseFactorization$/;"	s
LUFactorization	src/factorization.jl	/^LUFactorization(pivot) = LUFactorization(; pivot = RowMaximum())$/;"	f
LUSolver	src/simplelu.jl	/^function LUSolver(A::Matrix{T}) where {T}$/;"	f
LUSolver	src/simplelu.jl	/^function LUSolver(A::Matrix{T}, b::Vector{T}) where {T}$/;"	f
LUSolver	src/simplelu.jl	/^mutable struct LUSolver{T}$/;"	s
LUSolver{T}	src/simplelu.jl	/^    function LUSolver{T}(n) where {T}$/;"	f	struct:LUSolver
LUbx	src/KLU/wrappers.jl	/^    LUbx::Ptr{Ptr{Cvoid}}$/;"	g	struct:klu_l_numeric
LUbx	src/KLU/wrappers.jl	/^    LUbx::Ptr{Ptr{Cvoid}}$/;"	g	struct:klu_numeric
LUsize	src/KLU/wrappers.jl	/^    LUsize::Ptr{Csize_t}$/;"	g	struct:klu_l_numeric
LUsize	src/KLU/wrappers.jl	/^    LUsize::Ptr{Csize_t}$/;"	g	struct:klu_numeric
Lazy SciMLOperators	docs/src/solvers/solvers.md	/^### Lazy SciMLOperators$/;"	S	section:[Linear System Solvers](@id linearsystemsolvers)""Recommended Methods
Linear Problems	docs/src/basics/LinearProblem.md	/^# Linear Problems$/;"	c
Linear Solve with Caching Interface	docs/src/tutorials/caching_interface.md	/^# Linear Solve with Caching Interface$/;"	c
LinearCache	src/common.jl	/^mutable struct LinearCache{TA, Tb, Tu, Tp, Talg, Tc, Tl, Tr, Ttol, issq, S}$/;"	s
LinearCacheHYPRE	ext/LinearSolveHYPREExt.jl	/^const LinearCacheHYPRE = LinearCache{<:Any, <:Any, <:Any, <:Any, <:Any, HYPRECache}$/;"	c
LinearProblem	ext/LinearSolveHYPREExt.jl	/^function SciMLBase.LinearProblem(A::HYPREMatrix, b::HYPREVector,$/;"	f	module:SciMLBase
LinearSolve	src/LinearSolve.jl	/^module LinearSolve$/;"	n
LinearSolve.jl	README.md	/^# LinearSolve.jl$/;"	c
LinearSolve.jl	docs/src/solvers/solvers.md	/^### LinearSolve.jl$/;"	S	section:[Linear System Solvers](@id linearsystemsolvers)""Full List of Methods
LinearSolve.jl: High-Performance Unified Linear Solvers	docs/src/index.md	/^# LinearSolve.jl: High-Performance Unified Linear Solvers$/;"	c
LinearSolveAdjoint	src/adjoint.jl	/^@kwdef struct LinearSolveAdjoint{L} <:$/;"	s
LinearSolveBandedMatricesExt	ext/LinearSolveBandedMatricesExt.jl	/^module LinearSolveBandedMatricesExt$/;"	n
LinearSolveBlockDiagonalsExt	ext/LinearSolveBlockDiagonalsExt.jl	/^module LinearSolveBlockDiagonalsExt$/;"	n
LinearSolveCUDAExt	ext/LinearSolveCUDAExt.jl	/^module LinearSolveCUDAExt$/;"	n
LinearSolveCUDSSExt	ext/LinearSolveCUDSSExt.jl	/^module LinearSolveCUDSSExt$/;"	n
LinearSolveEnzymeExt	ext/LinearSolveEnzymeExt.jl	/^module LinearSolveEnzymeExt$/;"	n
LinearSolveFastAlmostBandedMatricesExt	ext/LinearSolveFastAlmostBandedMatricesExt.jl	/^module LinearSolveFastAlmostBandedMatricesExt$/;"	n
LinearSolveFastLapackInterfaceExt	ext/LinearSolveFastLapackInterfaceExt.jl	/^module LinearSolveFastLapackInterfaceExt$/;"	n
LinearSolveForwardDiffExt	ext/LinearSolveForwardDiffExt.jl	/^module LinearSolveForwardDiffExt$/;"	n
LinearSolveFunction	src/solve_function.jl	/^struct LinearSolveFunction{F} <: AbstractSolveFunction$/;"	s
LinearSolveHYPREExt	ext/LinearSolveHYPREExt.jl	/^module LinearSolveHYPREExt$/;"	n
LinearSolveIterativeSolversExt	ext/LinearSolveIterativeSolversExt.jl	/^module LinearSolveIterativeSolversExt$/;"	n
LinearSolveKernelAbstractionsExt	ext/LinearSolveKernelAbstractionsExt.jl	/^module LinearSolveKernelAbstractionsExt$/;"	n
LinearSolveKrylovKitExt	ext/LinearSolveKrylovKitExt.jl	/^module LinearSolveKrylovKitExt$/;"	n
LinearSolveMetalExt	ext/LinearSolveMetalExt.jl	/^module LinearSolveMetalExt$/;"	n
LinearSolvePardisoExt	ext/LinearSolvePardisoExt.jl	/^module LinearSolvePardisoExt$/;"	n
LinearSolveRecursiveFactorizationExt	ext/LinearSolveRecursiveFactorizationExt.jl	/^module LinearSolveRecursiveFactorizationExt$/;"	n
LinearSolveSparseArraysExt	ext/LinearSolveSparseArraysExt.jl	/^module LinearSolveSparseArraysExt$/;"	n
LinearSolveSparspakExt	ext/LinearSolveSparspakExt.jl	/^module LinearSolveSparspakExt$/;"	n
Lip	src/KLU/wrappers.jl	/^    Lip::Ptr{Int32}$/;"	g	struct:klu_numeric
Lip	src/KLU/wrappers.jl	/^    Lip::Ptr{Int64}$/;"	g	struct:klu_l_numeric
Llen	src/KLU/wrappers.jl	/^    Llen::Ptr{Int32}$/;"	g	struct:klu_numeric
Llen	src/KLU/wrappers.jl	/^    Llen::Ptr{Int64}$/;"	g	struct:klu_l_numeric
Lnz	src/KLU/wrappers.jl	/^    Lnz::Ptr{Cdouble}$/;"	g	struct:klu_l_symbolic
Lnz	src/KLU/wrappers.jl	/^    Lnz::Ptr{Cdouble}$/;"	g	struct:klu_symbolic
MKL.jl	docs/src/solvers/solvers.md	/^### MKL.jl$/;"	S	section:[Linear System Solvers](@id linearsystemsolvers)""Full List of Methods
MKLLUFactorization	src/default.jl	/^    MKLLUFactorization::T18$/;"	g	struct:DefaultLinearSolverInit
MKLLUFactorization	src/mkl.jl	/^struct MKLLUFactorization <: AbstractFactorization end$/;"	s
MKLPardisoFactorize	src/extension_algs.jl	/^MKLPardisoFactorize(; kwargs...) = PardisoJL(; vendor = :MKL, solver_type = 0, kwargs...)$/;"	f
MKLPardisoIterate	src/extension_algs.jl	/^MKLPardisoIterate(; kwargs...) = PardisoJL(; vendor = :MKL, solver_type = 1, kwargs...)$/;"	f
Mathematical Definition	docs/src/basics/Preconditioners.md	/^### Mathematical Definition$/;"	S	section:[Preconditioners](@id prec)""Using Preconditioners
Metal.jl	docs/src/solvers/solvers.md	/^### Metal.jl$/;"	S	section:[Linear System Solvers](@id linearsystemsolvers)""Full List of Methods
MetalLUFactorization	src/extension_algs.jl	/^struct MetalLUFactorization <: AbstractFactorization end$/;"	s
MySparseMatrixCSC	test/basictests.jl	/^    struct MySparseMatrixCSC{Tv, Ti} <: SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}$/;"	s
MySparseMatrixCSC2	test/pardiso/pardiso.jl	/^    struct MySparseMatrixCSC2{Tv, Ti} <: SparseArrays.AbstractSparseMatrixCSC{Tv, Ti}$/;"	s
NO_COMM_SOLVERS	ext/LinearSolveHYPREExt.jl	/^const NO_COMM_SOLVERS = Union{HYPRE.BoomerAMG, HYPRE.Hybrid, HYPRE.ILU}$/;"	c
NormalBunchKaufmanFactorization	src/factorization.jl	/^function NormalBunchKaufmanFactorization(; rook = false)$/;"	f
NormalBunchKaufmanFactorization	src/factorization.jl	/^struct NormalBunchKaufmanFactorization <: AbstractDenseFactorization$/;"	s
NormalCholeskyFactorization	src/default.jl	/^    NormalCholeskyFactorization::T16$/;"	g	struct:DefaultLinearSolverInit
NormalCholeskyFactorization	src/factorization.jl	/^function NormalCholeskyFactorization(; pivot = nothing)$/;"	f
NormalCholeskyFactorization	src/factorization.jl	/^struct NormalCholeskyFactorization{P} <: AbstractDenseFactorization$/;"	s
Offi	src/KLU/wrappers.jl	/^    Offi::Ptr{Int32}$/;"	g	struct:klu_numeric
Offi	src/KLU/wrappers.jl	/^    Offi::Ptr{Int64}$/;"	g	struct:klu_l_numeric
Offp	src/KLU/wrappers.jl	/^    Offp::Ptr{Int32}$/;"	g	struct:klu_numeric
Offp	src/KLU/wrappers.jl	/^    Offp::Ptr{Int64}$/;"	g	struct:klu_l_numeric
Offx	src/KLU/wrappers.jl	/^    Offx::Ptr{Cvoid}$/;"	g	struct:klu_l_numeric
Offx	src/KLU/wrappers.jl	/^    Offx::Ptr{Cvoid}$/;"	g	struct:klu_numeric
OperatorAssumptions	src/common.jl	/^function OperatorAssumptions(issquare = nothing;$/;"	f
OperatorAssumptions	src/common.jl	/^struct OperatorAssumptions{T}$/;"	s
P	src/KLU/wrappers.jl	/^    P::Ptr{Int32}$/;"	g	struct:klu_symbolic
P	src/KLU/wrappers.jl	/^    P::Ptr{Int64}$/;"	g	struct:klu_l_symbolic
P	src/preconditioners.jl	/^    P::T$/;"	g	struct:InvPreconditioner
PREALLOCATED_APPLE_LU	src/appleaccelerate.jl	/^const PREALLOCATED_APPLE_LU = begin$/;"	c
PREALLOCATED_BUNCHKAUFMAN	src/factorization.jl	/^const PREALLOCATED_BUNCHKAUFMAN = ArrayInterface.bunchkaufman_instance(Symmetric(rand(1,$/;"	c
PREALLOCATED_CHOLESKY	src/factorization.jl	/^const PREALLOCATED_CHOLESKY = ArrayInterface.cholesky_instance(rand(1, 1), NoPivot())$/;"	c
PREALLOCATED_CHOLMOD	ext/LinearSolveSparseArraysExt.jl	/^const PREALLOCATED_CHOLMOD = cholesky(sparse(reshape([1.0],1,1)))$/;"	c	module:LinearSolveSparseArraysExt
PREALLOCATED_IPIV	src/factorization.jl	/^const PREALLOCATED_IPIV = Vector{LinearAlgebra.BlasInt}(undef, 0)$/;"	c
PREALLOCATED_KLU	ext/LinearSolveSparseArraysExt.jl	/^const PREALLOCATED_KLU = KLU.KLUFactorization(SparseMatrixCSC(0, 0, [1], Int[],$/;"	c	module:LinearSolveSparseArraysExt
PREALLOCATED_LU	src/factorization.jl	/^const PREALLOCATED_LU = ArrayInterface.lu_instance(rand(1, 1))$/;"	c
PREALLOCATED_MKL_LU	src/mkl.jl	/^const PREALLOCATED_MKL_LU = begin$/;"	c
PREALLOCATED_NORMALCHOLESKY	src/factorization.jl	/^const PREALLOCATED_NORMALCHOLESKY = ArrayInterface.cholesky_instance(rand(1, 1), NoPivot())$/;"	c
PREALLOCATED_NORMALCHOLESKY_SYMMETRIC	src/factorization.jl	/^const PREALLOCATED_NORMALCHOLESKY_SYMMETRIC = ArrayInterface.cholesky_instance($/;"	c
PREALLOCATED_QR_ColumnNorm	src/factorization.jl	/^const PREALLOCATED_QR_ColumnNorm = ArrayInterface.qr_instance(rand(1, 1), ColumnNorm())$/;"	c
PREALLOCATED_QR_NoPivot	src/factorization.jl	/^const PREALLOCATED_QR_NoPivot = ArrayInterface.qr_instance(rand(1, 1))$/;"	c
PREALLOCATED_SPARSEPAK	ext/LinearSolveSparspakExt.jl	/^const PREALLOCATED_SPARSEPAK = sparspaklu(SparseMatrixCSC(0, 0, [1], Int[], Float64[]),$/;"	c	module:LinearSolveSparspakExt
PREALLOCATED_SVD	src/factorization.jl	/^const PREALLOCATED_SVD = ArrayInterface.svd_instance(rand(1, 1))$/;"	c
PREALLOCATED_UMFPACK	ext/LinearSolveSparseArraysExt.jl	/^const PREALLOCATED_UMFPACK = SparseArrays.UMFPACK.UmfpackLU(SparseMatrixCSC(0, 0, [1],$/;"	c	module:LinearSolveSparseArraysExt
PanuaPardisoFactorize	src/extension_algs.jl	/^PanuaPardisoFactorize(; kwargs...) = PardisoJL(;$/;"	f
PanuaPardisoIterate	src/extension_algs.jl	/^PanuaPardisoIterate(; kwargs...) = PardisoJL(; vendor = :Panua, solver_type = 1, kwargs...)$/;"	f
Pardiso.jl	docs/src/solvers/solvers.md	/^### Pardiso.jl$/;"	S	section:[Linear System Solvers](@id linearsystemsolvers)""Full List of Methods
PardisoJL	src/extension_algs.jl	/^    function PardisoJL(; nprocs::Union{Int, Nothing} = nothing,$/;"	f	struct:PardisoJL
PardisoJL	src/extension_algs.jl	/^struct PardisoJL{T1, T2} <: AbstractSparseFactorization$/;"	s
Pinv	src/KLU/wrappers.jl	/^    Pinv::Ptr{Int32}$/;"	g	struct:klu_numeric
Pinv	src/KLU/wrappers.jl	/^    Pinv::Ptr{Int64}$/;"	g	struct:klu_l_numeric
Pl	src/common.jl	/^    Pl::Tl        # preconditioners$/;"	g	struct:LinearCache
Pl	src/simplegmres.jl	/^    Pr$/;"	g	struct:SimpleGMRESCache
PlisI	src/simplegmres.jl	/^    PlisI::Bool$/;"	g	struct:SimpleGMRESCache
Pnum	src/KLU/wrappers.jl	/^    Pnum::Ptr{Int32}$/;"	g	struct:klu_numeric
Pnum	src/KLU/wrappers.jl	/^    Pnum::Ptr{Int64}$/;"	g	struct:klu_l_numeric
Polyalgorithms	docs/src/solvers/solvers.md	/^### Polyalgorithms$/;"	S	section:[Linear System Solvers](@id linearsystemsolvers)""Full List of Methods
Pr	src/common.jl	/^    Pr::Tr$/;"	g	struct:LinearCache
Pr	src/simplegmres.jl	/^    Δx$/;"	g	struct:SimpleGMRESCache
Preconditioner Interface	docs/src/basics/Preconditioners.md	/^## Preconditioner Interface$/;"	s	chapter:[Preconditioners](@id prec)
PrisI	src/simplegmres.jl	/^    PrisI::Bool$/;"	g	struct:SimpleGMRESCache
Python's NumPy/SciPy just calls fast Fortran/C code, why would LinearSolve.jl be any better?	docs/src/basics/FAQ.md	/^## Python's NumPy\/SciPy just calls fast Fortran\/C code, why would LinearSolve.jl be any better/;"	s	chapter:Frequently Asked Questions
Q	src/KLU/wrappers.jl	/^    Q::Ptr{Int32}$/;"	g	struct:klu_symbolic
Q	src/KLU/wrappers.jl	/^    Q::Ptr{Int64}$/;"	g	struct:klu_l_symbolic
QRFactorization	src/default.jl	/^    QRFactorization::T2$/;"	g	struct:DefaultLinearSolverInit
QRFactorization	src/factorization.jl	/^QRFactorization(inplace = true) = QRFactorization(NoPivot(), 16, inplace)$/;"	f
QRFactorization	src/factorization.jl	/^function QRFactorization(pivot::LinearAlgebra.PivotingStrategy, inplace::Bool = true)$/;"	f
QRFactorization	src/factorization.jl	/^struct QRFactorization{P} <: AbstractDenseFactorization$/;"	s
QRFactorizationPivoted	src/default.jl	/^    QRFactorizationPivoted::T19$/;"	g	struct:DefaultLinearSolverInit
R	src/KLU/wrappers.jl	/^    R::Ptr{Int32}$/;"	g	struct:klu_symbolic
R	src/KLU/wrappers.jl	/^    R::Ptr{Int64}$/;"	g	struct:klu_l_symbolic
R	src/simplegmres.jl	/^    β$/;"	g	struct:SimpleGMRESCache
RFLUFactorization	src/default.jl	/^    RFLUFactorization::T10$/;"	g	struct:DefaultLinearSolverInit
RFLUFactorization	src/extension_algs.jl	/^    function RFLUFactorization(::Val{P}, ::Val{T}; throwerror = true) where {P, T}$/;"	f	struct:RFLUFactorization
RFLUFactorization	src/extension_algs.jl	/^function RFLUFactorization(; pivot = Val(true), thread = Val(true), throwerror = true)$/;"	f
RFLUFactorization	src/extension_algs.jl	/^struct RFLUFactorization{P, T} <: AbstractDenseFactorization$/;"	s
Recommended Methods	docs/src/solvers/solvers.md	/^## Recommended Methods$/;"	s	chapter:[Linear System Solvers](@id linearsystemsolvers)
RecursiveFactorization.jl	docs/src/solvers/solvers.md	/^### RecursiveFactorization.jl$/;"	S	section:[Linear System Solvers](@id linearsystemsolvers)""Full List of Methods
Release Notes	docs/src/release_notes.md	/^# Release Notes$/;"	c
Reproducibility	docs/src/index.md	/^## Reproducibility$/;"	s	chapter:LinearSolve.jl: High-Performance Unified Linear Solvers
Roadmap	docs/src/index.md	/^## Roadmap$/;"	s	chapter:LinearSolve.jl: High-Performance Unified Linear Solvers
Rs	src/KLU/wrappers.jl	/^    Rs::Ptr{Cdouble}$/;"	g	struct:klu_l_numeric
Rs	src/KLU/wrappers.jl	/^    Rs::Ptr{Cdouble}$/;"	g	struct:klu_numeric
SUITESPARSE_COMPILER_CLANG	src/KLU/wrappers.jl	/^const SUITESPARSE_COMPILER_CLANG = 0$/;"	c
SUITESPARSE_COMPILER_GCC	src/KLU/wrappers.jl	/^const SUITESPARSE_COMPILER_GCC = 0$/;"	c
SUITESPARSE_COMPILER_ICC	src/KLU/wrappers.jl	/^const SUITESPARSE_COMPILER_ICC = 0$/;"	c
SUITESPARSE_COMPILER_ICX	src/KLU/wrappers.jl	/^const SUITESPARSE_COMPILER_ICX = 0$/;"	c
SUITESPARSE_COMPILER_MSC	src/KLU/wrappers.jl	/^const SUITESPARSE_COMPILER_MSC = 0$/;"	c
SUITESPARSE_COMPILER_NVCC	src/KLU/wrappers.jl	/^const SUITESPARSE_COMPILER_NVCC = 0$/;"	c
SUITESPARSE_COMPILER_XLC	src/KLU/wrappers.jl	/^const SUITESPARSE_COMPILER_XLC = 0$/;"	c
SUITESPARSE_DATE	src/KLU/wrappers.jl	/^const SUITESPARSE_DATE = "Oct 7, 2023"$/;"	c
SUITESPARSE_MAIN_VERSION	src/KLU/wrappers.jl	/^const SUITESPARSE_MAIN_VERSION = 7$/;"	c
SUITESPARSE_OPENMP_GET_NUM_THREADS	src/KLU/wrappers.jl	/^const SUITESPARSE_OPENMP_GET_NUM_THREADS = 1$/;"	c
SUITESPARSE_OPENMP_GET_THREAD_ID	src/KLU/wrappers.jl	/^const SUITESPARSE_OPENMP_GET_THREAD_ID = 0$/;"	c
SUITESPARSE_OPENMP_GET_WTIME	src/KLU/wrappers.jl	/^const SUITESPARSE_OPENMP_GET_WTIME = 0$/;"	c
SUITESPARSE_OPENMP_MAX_THREADS	src/KLU/wrappers.jl	/^const SUITESPARSE_OPENMP_MAX_THREADS = 1$/;"	c
SUITESPARSE_SUBSUB_VERSION	src/KLU/wrappers.jl	/^const SUITESPARSE_SUBSUB_VERSION = 1$/;"	c
SUITESPARSE_SUB_VERSION	src/KLU/wrappers.jl	/^const SUITESPARSE_SUB_VERSION = 2$/;"	c
SUITESPARSE_VERSION	src/KLU/wrappers.jl	/^const SUITESPARSE_VERSION = SUITESPARSE_VER_CODE($/;"	c
SUITESPARSE_VER_CODE	src/KLU/wrappers.jl	/^SUITESPARSE_VER_CODE(main, sub) = main * 1000 + sub$/;"	f
SVDFactorization	src/default.jl	/^    SVDFactorization::T14$/;"	g	struct:DefaultLinearSolverInit
SVDFactorization	src/factorization.jl	/^SVDFactorization() = SVDFactorization(false, LinearAlgebra.DivideAndConquer())$/;"	f
SVDFactorization	src/factorization.jl	/^struct SVDFactorization{A} <: AbstractDenseFactorization$/;"	s
SciMLLinearSolveAlgorithm	src/LinearSolve.jl	/^abstract type SciMLLinearSolveAlgorithm <: SciMLBase.AbstractLinearAlgorithm end$/;"	t	module:LinearSolve
SimpleGMRES	src/simplegmres.jl	/^    function SimpleGMRES(; restart::Bool = true, blocksize::Int = 0,$/;"	f	struct:SimpleGMRES
SimpleGMRES	src/simplegmres.jl	/^struct SimpleGMRES{UBD} <: AbstractKrylovSubspaceMethod$/;"	s
SimpleGMRESCache	src/simplegmres.jl	/^@concrete mutable struct SimpleGMRESCache{UBD}$/;"	s
SimpleGMRES{UBD}	src/simplegmres.jl	/^    function SimpleGMRES{UBD}(; restart::Bool = true, blocksize::Int = 0,$/;"	f	struct:SimpleGMRES
SimpleLUFactorization	src/simplelu.jl	/^    SimpleLUFactorization(pivot = true) = new(pivot)$/;"	f	struct:SimpleLUFactorization
SimpleLUFactorization	src/simplelu.jl	/^struct SimpleLUFactorization <: AbstractFactorization$/;"	s
Sparse Matrices	docs/src/solvers/solvers.md	/^### Sparse Matrices$/;"	S	section:[Linear System Solvers](@id linearsystemsolvers)""Recommended Methods
Sparse Matrices on GPUs	docs/src/tutorials/gpu.md	/^## Sparse Matrices on GPUs$/;"	s	chapter:GPU-Accelerated Linear Solving in Julia
Sparse and Structured Matrices	docs/src/tutorials/linear.md	/^## Sparse and Structured Matrices$/;"	s	chapter:Getting Started with Solving Linear Systems in Julia
Sparspak.jl	docs/src/solvers/solvers.md	/^### Sparspak.jl$/;"	S	section:[Linear System Solvers](@id linearsystemsolvers)""Full List of Methods
SparspakFactorization	src/default.jl	/^    SparspakFactorization::T5$/;"	g	struct:DefaultLinearSolverInit
SparspakFactorization	src/factorization.jl	/^    function SparspakFactorization(; reuse_symbolic = true, throwerror = true)$/;"	f	struct:SparspakFactorization
SparspakFactorization	src/factorization.jl	/^struct SparspakFactorization <: AbstractSparseFactorization$/;"	s
Specifying  Preconditioners	docs/src/basics/Preconditioners.md	/^### Specifying  Preconditioners$/;"	S	section:[Preconditioners](@id prec)""Using Preconditioners
StaticLinearProblem	src/common.jl	/^const StaticLinearProblem = LinearProblem{uType, iip, <:SMatrix,$/;"	c
SuiteSparse.jl	docs/src/solvers/solvers.md	/^### SuiteSparse.jl$/;"	S	section:[Linear System Solvers](@id linearsystemsolvers)""Full List of Methods
SuiteSparse_BLAS_integer_size	src/KLU/wrappers.jl	/^function SuiteSparse_BLAS_integer_size()$/;"	f
SuiteSparse_BLAS_library	src/KLU/wrappers.jl	/^function SuiteSparse_BLAS_library()$/;"	f
SuiteSparse_calloc	src/KLU/wrappers.jl	/^function SuiteSparse_calloc(nitems, size_of_item)$/;"	f
SuiteSparse_config_calloc	src/KLU/wrappers.jl	/^function SuiteSparse_config_calloc(n, s)$/;"	f
SuiteSparse_config_calloc_func_get	src/KLU/wrappers.jl	/^function SuiteSparse_config_calloc_func_get()$/;"	f
SuiteSparse_config_calloc_func_set	src/KLU/wrappers.jl	/^function SuiteSparse_config_calloc_func_set(calloc_func)$/;"	f
SuiteSparse_config_divcomplex	src/KLU/wrappers.jl	/^function SuiteSparse_config_divcomplex(xr, xi, yr, yi, zr, zi)$/;"	f
SuiteSparse_config_divcomplex_func_get	src/KLU/wrappers.jl	/^function SuiteSparse_config_divcomplex_func_get()$/;"	f
SuiteSparse_config_divcomplex_func_set	src/KLU/wrappers.jl	/^function SuiteSparse_config_divcomplex_func_set(divcomplex_func)$/;"	f
SuiteSparse_config_free	src/KLU/wrappers.jl	/^function SuiteSparse_config_free(arg1)$/;"	f
SuiteSparse_config_free_func_get	src/KLU/wrappers.jl	/^function SuiteSparse_config_free_func_get()$/;"	f
SuiteSparse_config_free_func_set	src/KLU/wrappers.jl	/^function SuiteSparse_config_free_func_set(free_func)$/;"	f
SuiteSparse_config_hypot	src/KLU/wrappers.jl	/^function SuiteSparse_config_hypot(x, y)$/;"	f
SuiteSparse_config_hypot_func_get	src/KLU/wrappers.jl	/^function SuiteSparse_config_hypot_func_get()$/;"	f
SuiteSparse_config_hypot_func_set	src/KLU/wrappers.jl	/^function SuiteSparse_config_hypot_func_set(hypot_func)$/;"	f
SuiteSparse_config_malloc	src/KLU/wrappers.jl	/^function SuiteSparse_config_malloc(s)$/;"	f
SuiteSparse_config_malloc_func_get	src/KLU/wrappers.jl	/^function SuiteSparse_config_malloc_func_get()$/;"	f
SuiteSparse_config_malloc_func_set	src/KLU/wrappers.jl	/^function SuiteSparse_config_malloc_func_set(malloc_func)$/;"	f
SuiteSparse_config_printf_func_get	src/KLU/wrappers.jl	/^function SuiteSparse_config_printf_func_get()$/;"	f
SuiteSparse_config_printf_func_set	src/KLU/wrappers.jl	/^function SuiteSparse_config_printf_func_set(printf_func)$/;"	f
SuiteSparse_config_realloc	src/KLU/wrappers.jl	/^function SuiteSparse_config_realloc(arg1, s)$/;"	f
SuiteSparse_config_realloc_func_get	src/KLU/wrappers.jl	/^function SuiteSparse_config_realloc_func_get()$/;"	f
SuiteSparse_config_realloc_func_set	src/KLU/wrappers.jl	/^function SuiteSparse_config_realloc_func_set(realloc_func)$/;"	f
SuiteSparse_divcomplex	src/KLU/wrappers.jl	/^function SuiteSparse_divcomplex(ar, ai, br, bi, cr, ci)$/;"	f
SuiteSparse_finish	src/KLU/wrappers.jl	/^function SuiteSparse_finish()$/;"	f
SuiteSparse_free	src/KLU/wrappers.jl	/^function SuiteSparse_free(p)$/;"	f
SuiteSparse_hypot	src/KLU/wrappers.jl	/^function SuiteSparse_hypot(x, y)$/;"	f
SuiteSparse_malloc	src/KLU/wrappers.jl	/^function SuiteSparse_malloc(nitems, size_of_item)$/;"	f
SuiteSparse_realloc	src/KLU/wrappers.jl	/^function SuiteSparse_realloc(nitems_new, nitems_old, size_of_item, p, ok)$/;"	f
SuiteSparse_start	src/KLU/wrappers.jl	/^function SuiteSparse_start()$/;"	f
SuiteSparse_tic	src/KLU/wrappers.jl	/^function SuiteSparse_tic(tic)$/;"	f
SuiteSparse_time	src/KLU/wrappers.jl	/^function SuiteSparse_time()$/;"	f
SuiteSparse_toc	src/KLU/wrappers.jl	/^function SuiteSparse_toc(tic)$/;"	f
SuiteSparse_version	src/KLU/wrappers.jl	/^function SuiteSparse_version(version)$/;"	f
TOL	test/hypretests_mpi.jl	/^const TOL = LinearSolve.default_tol(HYPRE.LibHYPRE.HYPRE_Complex)$/;"	c
TransposeFact	src/KLU/klu.jl	/^const TransposeFact = isdefined(LinearAlgebra, :TransposeFactorization) ?$/;"	c	module:KLU
UMFPACKFactorization	src/default.jl	/^    UMFPACKFactorization::T7$/;"	g	struct:DefaultLinearSolverInit
UMFPACKFactorization	src/factorization.jl	/^Base.@kwdef struct UMFPACKFactorization <: AbstractSparseFactorization$/;"	s
Udiag	src/KLU/wrappers.jl	/^    Udiag::Ptr{Cvoid}$/;"	g	struct:klu_l_numeric
Udiag	src/KLU/wrappers.jl	/^    Udiag::Ptr{Cvoid}$/;"	g	struct:klu_numeric
Uip	src/KLU/wrappers.jl	/^    Uip::Ptr{Int32}$/;"	g	struct:klu_numeric
Uip	src/KLU/wrappers.jl	/^    Uip::Ptr{Int64}$/;"	g	struct:klu_l_numeric
Ulen	src/KLU/wrappers.jl	/^    Ulen::Ptr{Int32}$/;"	g	struct:klu_numeric
Ulen	src/KLU/wrappers.jl	/^    Ulen::Ptr{Int64}$/;"	g	struct:klu_l_numeric
Understanding Performance of Dense Linear Solves	docs/src/tutorials/accelerating_choices.md	/^## Understanding Performance of Dense Linear Solves$/;"	s	chapter:Accelerating your Linear Solves
Understanding Performance of Sparse Linear Solves	docs/src/tutorials/accelerating_choices.md	/^## Understanding Performance of Sparse Linear Solves$/;"	s	chapter:Accelerating your Linear Solves
Using Matrix-Free Operators via SciMLOperators.jl	docs/src/tutorials/linear.md	/^## Using Matrix-Free Operators via SciMLOperators.jl$/;"	s	chapter:Getting Started with Solving Linear Systems in Julia
Using Preconditioners	docs/src/basics/Preconditioners.md	/^## Using Preconditioners$/;"	s	chapter:[Preconditioners](@id prec)
V	src/simplegmres.jl	/^    s$/;"	g	struct:SimpleGMRESCache
Work	src/KLU/wrappers.jl	/^    Work::Ptr{Cvoid}$/;"	g	struct:klu_l_numeric
Work	src/KLU/wrappers.jl	/^    Work::Ptr{Cvoid}$/;"	g	struct:klu_numeric
WorkspaceAndFactors	ext/LinearSolveFastLapackInterfaceExt.jl	/^struct WorkspaceAndFactors{W, F}$/;"	s	module:LinearSolveFastLapackInterfaceExt
Xwork	src/KLU/wrappers.jl	/^    Xwork::Ptr{Cvoid}$/;"	g	struct:klu_l_numeric
Xwork	src/KLU/wrappers.jl	/^    Xwork::Ptr{Cvoid}$/;"	g	struct:klu_numeric
[Linear Solve Operator Assumptions](@id assumptions)	docs/src/basics/OperatorAssumptions.md	/^# [Linear Solve Operator Assumptions](@id assumptions)$/;"	c
[Linear System Solvers](@id linearsystemsolvers)	docs/src/solvers/solvers.md	/^# [Linear System Solvers](@id linearsystemsolvers)$/;"	c
[Passing in a Custom Linear Solver](@id custom)	docs/src/advanced/custom.md	/^# [Passing in a Custom Linear Solver](@id custom)$/;"	c
[Preconditioners](@id prec)	docs/src/basics/Preconditioners.md	/^# [Preconditioners](@id prec)$/;"	c
__appleaccelerate_isavailable	src/appleaccelerate.jl	/^    __appleaccelerate_isavailable() = false$/;"	f
__appleaccelerate_isavailable	src/appleaccelerate.jl	/^    function __appleaccelerate_isavailable()$/;"	f
__conditioning	src/common.jl	/^__conditioning(assump::OperatorAssumptions) = assump.condition$/;"	f
__fast_sym_givens_kernel!	ext/LinearSolveKernelAbstractionsExt.jl	/^@kernel function __fast_sym_givens_kernel!(c, s, R, @Const(Hbis))$/;"	f	module:LinearSolveKernelAbstractionsExt
__init__	src/init.jl	/^function __init__()$/;"	f
__init_u0_from_Ab	src/common.jl	/^__init_u0_from_Ab(::SMatrix{S1, S2}, b) where {S1, S2} = zeros(SVector{S2, eltype(b)})$/;"	f
__init_u0_from_Ab	src/common.jl	/^function __init_u0_from_Ab(A, b)$/;"	f
__is_extension_loaded	ext/LinearSolveKernelAbstractionsExt.jl	/^LinearSolve.__is_extension_loaded(::Val{:KernelAbstractions}) = true$/;"	f	module:LinearSolve
__is_extension_loaded	src/LinearSolve.jl	/^__is_extension_loaded(::Val) = false$/;"	f	module:LinearSolve
__issquare	src/common.jl	/^__issquare(assump::OperatorAssumptions) = assump.issq$/;"	f
__non_native_static_array_alg	test/nopre/static_arrays.jl	/^function __non_native_static_array_alg(alg)$/;"	f
__parameterless_type	benchmarks/applelu.jl	/^__parameterless_type(T) = Base.typename(T).wrapper$/;"	f
__parameterless_type	benchmarks/cudalu.jl	/^__parameterless_type(T) = Base.typename(T).wrapper$/;"	f
__parameterless_type	benchmarks/lu.jl	/^__parameterless_type(T) = Base.typename(T).wrapper$/;"	f
__parameterless_type	benchmarks/metallu.jl	/^__parameterless_type(T) = Base.typename(T).wrapper$/;"	f
__parameterless_type	benchmarks/sparselu.jl	/^__parameterless_type(T) = Base.typename(T).wrapper$/;"	f
__setfield!	src/default.jl	/^@generated function __setfield!(cache::DefaultLinearSolverInit, alg::DefaultLinearSolver, v)$/;"	f
__setfield!	src/default.jl	/^function __setfield!(cache::DefaultLinearSolverInit, alg::DefaultLinearSolver, v::LinearAlgebra./;"	f
__solve_no_alloc	test/nopre/static_arrays.jl	/^@check_allocs __solve_no_alloc(A, b, alg) = solve(LinearProblem(A, b), alg)$/;"	f
_common	src/KLU/klu.jl	/^function _common(T)$/;"	f	module:KLU
_extract!	src/KLU/klu.jl	/^        function _extract!($/;"	f
_fast_sym_givens!	ext/LinearSolveKernelAbstractionsExt.jl	/^function LinearSolve._fast_sym_givens!(c, s, R, nr::Int, inner_iter::Int, bsize::Int, Hbis)$/;"	f	module:LinearSolve
_fast_sym_givens!	src/LinearSolve.jl	/^function _fast_sym_givens! end$/;"	f	module:LinearSolve
_free_numeric	src/KLU/klu.jl	/^        function _free_numeric(K::AbstractKLUFactorization{$Tv, $Ti})$/;"	f
_free_symbolic	src/KLU/klu.jl	/^function _free_symbolic(K::AbstractKLUFactorization{Tv, Ti}) where {Ti <: KLUITypes, Tv}$/;"	f
_init_cacheval	src/simplegmres.jl	/^function _init_cacheval(::Val{false}, alg::SimpleGMRES, A, b, u, Pl, Pr, maxiters::Int,$/;"	f
_init_cacheval	src/simplegmres.jl	/^function _init_cacheval(::Val{true}, alg::SimpleGMRES, A, b, u, Pl, Pr, maxiters::Int,$/;"	f
_isidentity_struct	ext/LinearSolveIterativeSolversExt.jl	/^LinearSolve._isidentity_struct(::IterativeSolvers.Identity) = true$/;"	f	module:LinearSolve
_isidentity_struct	src/LinearSolve.jl	/^_isidentity_struct(::SciMLOperators.IdentityOperator) = true$/;"	f	module:LinearSolve
_isidentity_struct	src/LinearSolve.jl	/^_isidentity_struct(A) = false$/;"	f	module:LinearSolve
_isidentity_struct	src/LinearSolve.jl	/^_isidentity_struct(A::UniformScaling) = isone(A.λ)$/;"	f	module:LinearSolve
_isidentity_struct	src/LinearSolve.jl	/^_isidentity_struct(λ::Number) = isone(λ)$/;"	f	module:LinearSolve
_klu_name	src/KLU/klu.jl	/^function _klu_name(name, Tv, Ti)$/;"	f	module:KLU
_ldiv!	ext/LinearSolveSparseArraysExt.jl	/^function LinearSolve._ldiv!(::SVector,$/;"	f	module:LinearSolve
_ldiv!	ext/LinearSolveSparseArraysExt.jl	/^function LinearSolve._ldiv!(x::AbstractVector,$/;"	f	module:LinearSolve
_ldiv!	ext/LinearSolveSparseArraysExt.jl	/^function LinearSolve._ldiv!(x::Vector,$/;"	f	module:LinearSolve
_ldiv!	src/factorization.jl	/^_ldiv!(::SVector, A, b) = (A \\ b)$/;"	f
_ldiv!	src/factorization.jl	/^_ldiv!(::SVector, A, b::SVector) = (A \\ b)$/;"	f
_ldiv!	src/factorization.jl	/^_ldiv!(x, A, b) = ldiv!(x, A, b)$/;"	f
_ldiv!	src/factorization.jl	/^_ldiv!(x, A, b::SVector) = (x .= A \\ b)$/;"	f
_ldiv!	src/factorization.jl	/^function _ldiv!(x::Vector, A::Factorization, b::Vector)$/;"	f
_no_preconditioner	src/simplegmres.jl	/^_no_preconditioner(::IdentityOperator) = true$/;"	f
_no_preconditioner	src/simplegmres.jl	/^_no_preconditioner(::Nothing) = true$/;"	f
_no_preconditioner	src/simplegmres.jl	/^_no_preconditioner(::UniformScaling) = true$/;"	f
_no_preconditioner	src/simplegmres.jl	/^_no_preconditioner(_) = false$/;"	f
_norm2	src/simplegmres.jl	/^_norm2(x) = norm(x, 2)$/;"	f
_norm2	src/simplegmres.jl	/^_norm2(x, dims) = .√(sum(abs2, x; dims))$/;"	f
_notsuccessful	src/LinearSolve.jl	/^@inline _notsuccessful(F) = hasmethod(LinearAlgebra.issuccess, (typeof(F),)) ?$/;"	f
_notsuccessful	src/LinearSolve.jl	/^@inline function _notsuccessful(F::LinearAlgebra.QRCompactWY)$/;"	f
_numeric	src/KLU/klu.jl	/^    _numeric::Ptr{Cvoid}$/;"	g	struct:KLU.KLUFactorization
_sym_givens	src/simplegmres.jl	/^function _sym_givens(a::T, b::T) where {T <: AbstractFloat}$/;"	f
_sym_givens!	src/simplegmres.jl	/^function _sym_givens!(c, s, R, nr::Int, inner_iter::Int, bsize::Int, Hbis)$/;"	f
_symbolic	src/KLU/klu.jl	/^    _symbolic::Ptr{Cvoid}$/;"	g	struct:KLU.KLUFactorization
aa_getrf!	src/appleaccelerate.jl	/^function aa_getrf!(A::AbstractMatrix{<:ComplexF32};$/;"	f
aa_getrf!	src/appleaccelerate.jl	/^function aa_getrf!(A::AbstractMatrix{<:ComplexF64};$/;"	f
aa_getrf!	src/appleaccelerate.jl	/^function aa_getrf!(A::AbstractMatrix{<:Float32};$/;"	f
aa_getrf!	src/appleaccelerate.jl	/^function aa_getrf!(A::AbstractMatrix{<:Float64};$/;"	f
aa_getrs!	src/appleaccelerate.jl	/^function aa_getrs!(trans::AbstractChar,$/;"	f
abstol	src/common.jl	/^    abstol::Ttol$/;"	g	struct:LinearCache
abstol	src/simplegmres.jl	/^    reltol$/;"	g	struct:SimpleGMRESCache
adjoint	src/KLU/klu.jl	/^    Base.adjoint(K::AbstractKLUFactorization) = Adjoint(K)$/;"	f	module:Base
alg	src/LinearSolve.jl	/^    alg::DefaultAlgorithmChoice.T$/;"	g	struct:LinearSolve.DefaultLinearSolver
alg	src/common.jl	/^    alg::Talg$/;"	g	struct:LinearCache
alg	src/factorization.jl	/^    alg::A$/;"	g	struct:SVDFactorization
algchoice_to_alg	src/default.jl	/^function algchoice_to_alg(alg::Symbol)$/;"	f
amd_2	src/KLU/wrappers.jl	/^function amd_2($/;"	f
amd_control	src/KLU/wrappers.jl	/^function amd_control(Control)$/;"	f
amd_defaults	src/KLU/wrappers.jl	/^function amd_defaults(Control)$/;"	f
amd_info	src/KLU/wrappers.jl	/^function amd_info(Info)$/;"	f
amd_l2	src/KLU/wrappers.jl	/^function amd_l2($/;"	f
amd_l_control	src/KLU/wrappers.jl	/^function amd_l_control(Control)$/;"	f
amd_l_defaults	src/KLU/wrappers.jl	/^function amd_l_defaults(Control)$/;"	f
amd_l_info	src/KLU/wrappers.jl	/^function amd_l_info(Info)$/;"	f
amd_l_order	src/KLU/wrappers.jl	/^function amd_l_order(n, Ap, Ai, P, Control, Info)$/;"	f
amd_l_valid	src/KLU/wrappers.jl	/^function amd_l_valid(n_row, n_col, Ap, Ai)$/;"	f
amd_order	src/KLU/wrappers.jl	/^function amd_order(n, Ap, Ai, P, Control, Info)$/;"	f
amd_valid	src/KLU/wrappers.jl	/^function amd_valid(n_row, n_col, Ap, Ai)$/;"	f
appleaccelerate_isavailable	src/LinearSolve.jl	/^appleaccelerate_isavailable() = HAS_APPLE_ACCELERATE[]$/;"	f
args	src/extension_algs.jl	/^    args::A$/;"	g	struct:IterativeSolversJL
args	src/extension_algs.jl	/^    args::A$/;"	g	struct:KrylovKitJL
args	src/iterative_wrappers.jl	/^    args::A$/;"	g	struct:KrylovJL
assumptions	src/common.jl	/^    assumptions::OperatorAssumptions{issq}$/;"	g	struct:LinearCache
augmented_primal	ext/LinearSolveEnzymeExt.jl	/^function EnzymeRules.augmented_primal($/;"	f	module:EnzymeRules
b	ext/LinearSolveHYPREExt.jl	/^    b::Union{HYPREVector, Nothing}$/;"	g	struct:LinearSolveHYPREExt.HYPRECache
b	src/common.jl	/^    b::Tb$/;"	g	struct:LinearCache
b	src/simplegmres.jl	/^    abstol$/;"	g	struct:SimpleGMRESCache
b	src/simplelu.jl	/^    b::Vector{T}$/;"	g	struct:LUSolver
blocksize	src/extension_algs.jl	/^    blocksize::Int$/;"	g	struct:FastQRFactorization
blocksize	src/factorization.jl	/^    blocksize::Int$/;"	g	struct:QRFactorization
blocksize	src/simplegmres.jl	/^    blocksize::Int$/;"	g	struct:SimpleGMRES
blocksize	src/simplegmres.jl	/^    blocksize::Int$/;"	g	struct:SimpleGMRESCache
btf	src/KLU/wrappers.jl	/^    btf::Cint$/;"	g	struct:klu_common_struct
btf	src/KLU/wrappers.jl	/^    btf::Cint$/;"	g	struct:klu_l_common_struct
btf_l_maxtrans	src/KLU/wrappers.jl	/^function btf_l_maxtrans(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)$/;"	f
btf_l_order	src/KLU/wrappers.jl	/^function btf_l_order(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)$/;"	f
btf_l_strongcomp	src/KLU/wrappers.jl	/^function btf_l_strongcomp(arg1, arg2, arg3, arg4, arg5, arg6, arg7)$/;"	f
btf_maxtrans	src/KLU/wrappers.jl	/^function btf_maxtrans(nrow, ncol, Ap, Ai, maxwork, work, Match, Work)$/;"	f
btf_order	src/KLU/wrappers.jl	/^function btf_order(n, Ap, Ai, maxwork, work, P, Q, R, nmatch, Work)$/;"	f
btf_strongcomp	src/KLU/wrappers.jl	/^function btf_strongcomp(n, Ap, Ai, Q, P, R, Work)$/;"	f
c	src/simplegmres.jl	/^    z$/;"	g	struct:SimpleGMRESCache
cache_analysis	src/extension_algs.jl	/^    cache_analysis::Bool$/;"	g	struct:PardisoJL
cacheval	src/common.jl	/^    cacheval::Tc  # store alg cache here$/;"	g	struct:LinearCache
check_pattern	src/factorization.jl	/^    check_pattern::Bool = true # Check factorization re-use$/;"	g	struct:LUFactorization
check_pattern	src/factorization.jl	/^    check_pattern::Bool = true # Check factorization re-use$/;"	g	struct:UMFPACKFactorization
check_pattern	src/factorization.jl	/^    check_pattern::Bool = true$/;"	g	struct:KLUFactorization
colamd	src/KLU/wrappers.jl	/^function colamd(n_row, n_col, Alen, A, p, knobs, stats)$/;"	f
colamd_l	src/KLU/wrappers.jl	/^function colamd_l(n_row, n_col, Alen, A, p, knobs, stats)$/;"	f
colamd_l_recommended	src/KLU/wrappers.jl	/^function colamd_l_recommended(nnz, n_row, n_col)$/;"	f
colamd_l_report	src/KLU/wrappers.jl	/^function colamd_l_report(stats)$/;"	f
colamd_l_set_defaults	src/KLU/wrappers.jl	/^function colamd_l_set_defaults(knobs)$/;"	f
colamd_recommended	src/KLU/wrappers.jl	/^function colamd_recommended(nnz, n_row, n_col)$/;"	f
colamd_report	src/KLU/wrappers.jl	/^function colamd_report(stats)$/;"	f
colamd_set_defaults	src/KLU/wrappers.jl	/^function colamd_set_defaults(knobs)$/;"	f
colptr	src/KLU/klu.jl	/^    colptr::Vector{Ti}$/;"	g	struct:KLU.KLUFactorization
comm	test/hypretests.jl	/^const comm = MPI.COMM_WORLD$/;"	c
comm	test/hypretests_mpi.jl	/^const comm = MPI.COMM_WORLD$/;"	c
comm_size	test/hypretests_mpi.jl	/^const comm_size = MPI.Comm_size(comm)$/;"	c
common	src/KLU/klu.jl	/^    common::Union{klu_l_common, klu_common}$/;"	g	struct:KLU.KLUFactorization
condest	src/KLU/klu.jl	/^        function condest(K::KLUFactorization{$Tv, $Ti})$/;"	f
condest	src/KLU/wrappers.jl	/^    condest::Cdouble$/;"	g	struct:klu_common_struct
condest	src/KLU/wrappers.jl	/^    condest::Cdouble$/;"	g	struct:klu_l_common_struct
condition	src/common.jl	/^    condition::OperatorCondition.T$/;"	g	struct:OperatorAssumptions
countingprecs	test/basictests.jl	/^        function countingprecs(A, p = nothing)$/;"	f
create_solver	ext/LinearSolveHYPREExt.jl	/^create_solver(::Type{S}, comm) where {S <: COMM_SOLVERS} = S(comm)$/;"	f
create_solver	ext/LinearSolveHYPREExt.jl	/^create_solver(::Type{S}, comm) where {S <: NO_COMM_SOLVERS} = S()$/;"	f
create_solver	ext/LinearSolveHYPREExt.jl	/^function create_solver(alg::HYPREAlgorithm, cache::LinearCache)$/;"	f
csc	test/basictests.jl	/^        csc::SparseMatrixCSC{Tv, Ti}$/;"	g	struct:MySparseMatrixCSC
csc	test/pardiso/pardiso.jl	/^        csc::SparseMatrixCSC{Tv, Ti}$/;"	g	struct:MySparseMatrixCSC2
cudss_loaded	ext/LinearSolveCUDSSExt.jl	/^LinearSolve.cudss_loaded(A::CUDSS.CUDA.CUSPARSE.CuSparseMatrixCSR) = true$/;"	f	module:LinearSolve
cudss_loaded	src/LinearSolve.jl	/^cudss_loaded(A) = false$/;"	f
decrement	src/KLU/klu.jl	/^decrement(A::AbstractArray{<:Integer}) = decrement!(copy(A))$/;"	f	module:KLU
decrement!	src/KLU/klu.jl	/^function decrement!(A::AbstractArray{T}) where {T <: Integer}$/;"	f	module:KLU
default_alias_A	ext/LinearSolveIterativeSolversExt.jl	/^LinearSolve.default_alias_A(::IterativeSolversJL, ::Any, ::Any) = true$/;"	f	module:LinearSolve
default_alias_A	ext/LinearSolveKrylovKitExt.jl	/^LinearSolve.default_alias_A(::KrylovKitJL, ::Any, ::Any) = true$/;"	f	module:LinearSolve
default_alias_A	ext/LinearSolveMetalExt.jl	/^default_alias_A(::MetalLUFactorization, ::Any, ::Any) = false$/;"	f	module:LinearSolveMetalExt
default_alias_A	src/appleaccelerate.jl	/^default_alias_A(::AppleAccelerateLUFactorization, ::Any, ::Any) = false$/;"	f
default_alias_A	src/common.jl	/^default_alias_A(::AbstractKrylovSubspaceMethod, ::Any, ::Any) = true$/;"	f
default_alias_A	src/common.jl	/^default_alias_A(::AbstractSparseFactorization, ::Any, ::Any) = true$/;"	f
default_alias_A	src/common.jl	/^default_alias_A(::Any, ::Any, ::Any) = false$/;"	f
default_alias_A	src/factorization.jl	/^default_alias_A(::NormalBunchKaufmanFactorization, ::Any, ::Any) = true$/;"	f
default_alias_A	src/factorization.jl	/^default_alias_A(::NormalCholeskyFactorization, ::Any, ::Any) = true$/;"	f
default_alias_A	src/iterative_wrappers.jl	/^default_alias_A(::KrylovJL, ::Any, ::Any) = true$/;"	f
default_alias_A	src/mkl.jl	/^default_alias_A(::MKLLUFactorization, ::Any, ::Any) = false$/;"	f
default_alias_A	src/simplegmres.jl	/^default_alias_A(::SimpleGMRES, ::Any, ::Any) = false$/;"	f
default_alias_A	src/simplelu.jl	/^default_alias_A(::SimpleLUFactorization, ::Any, ::Any) = true$/;"	f
default_alias_b	ext/LinearSolveIterativeSolversExt.jl	/^LinearSolve.default_alias_b(::IterativeSolversJL, ::Any, ::Any) = true$/;"	f	module:LinearSolve
default_alias_b	ext/LinearSolveKrylovKitExt.jl	/^LinearSolve.default_alias_b(::KrylovKitJL, ::Any, ::Any) = true$/;"	f	module:LinearSolve
default_alias_b	ext/LinearSolveMetalExt.jl	/^default_alias_b(::MetalLUFactorization, ::Any, ::Any) = false$/;"	f	module:LinearSolveMetalExt
default_alias_b	src/appleaccelerate.jl	/^default_alias_b(::AppleAccelerateLUFactorization, ::Any, ::Any) = false$/;"	f
default_alias_b	src/common.jl	/^default_alias_b(::AbstractKrylovSubspaceMethod, ::Any, ::Any) = true$/;"	f
default_alias_b	src/common.jl	/^default_alias_b(::AbstractSparseFactorization, ::Any, ::Any) = true$/;"	f
default_alias_b	src/common.jl	/^default_alias_b(::Any, ::Any, ::Any) = false$/;"	f
default_alias_b	src/factorization.jl	/^default_alias_b(::NormalBunchKaufmanFactorization, ::Any, ::Any) = true$/;"	f
default_alias_b	src/factorization.jl	/^default_alias_b(::NormalCholeskyFactorization, ::Any, ::Any) = true$/;"	f
default_alias_b	src/iterative_wrappers.jl	/^default_alias_b(::KrylovJL, ::Any, ::Any) = true$/;"	f
default_alias_b	src/mkl.jl	/^default_alias_b(::MKLLUFactorization, ::Any, ::Any) = false$/;"	f
default_alias_b	src/simplegmres.jl	/^default_alias_b(::SimpleGMRES, ::Any, ::Any) = false$/;"	f
default_alias_b	src/simplelu.jl	/^default_alias_b(::SimpleLUFactorization, ::Any, ::Any) = true$/;"	f
default_tol	src/common.jl	/^default_tol(::Type{<:Integer}) = 0$/;"	f
default_tol	src/common.jl	/^default_tol(::Type{<:Rational}) = 0$/;"	f
default_tol	src/common.jl	/^default_tol(::Type{Any}) = 0$/;"	f
default_tol	src/common.jl	/^default_tol(::Type{Complex{T}}) where {T} = √(eps(T))$/;"	f
default_tol	src/common.jl	/^default_tol(::Type{T}) where {T} = √(eps(T))$/;"	f
defaultalg	ext/LinearSolveBandedMatricesExt.jl	/^function defaultalg($/;"	f	module:LinearSolveBandedMatricesExt
defaultalg	ext/LinearSolveBandedMatricesExt.jl	/^function defaultalg(A::BandedMatrix, b, oa::OperatorAssumptions{Bool})$/;"	f	module:LinearSolveBandedMatricesExt
defaultalg	ext/LinearSolveBandedMatricesExt.jl	/^function defaultalg(A::Symmetric{<:Number, <:BandedMatrix}, b, ::OperatorAssumptions{Bool})$/;"	f	module:LinearSolveBandedMatricesExt
defaultalg	ext/LinearSolveCUDAExt.jl	/^function LinearSolve.defaultalg(A::CUDA.CUSPARSE.CuSparseMatrixCSR{Tv, Ti}, b,$/;"	f	module:LinearSolve
defaultalg	ext/LinearSolveFastAlmostBandedMatricesExt.jl	/^function defaultalg(A::AlmostBandedMatrix, b, oa::OperatorAssumptions{Bool})$/;"	f	module:LinearSolveFastAlmostBandedMatricesExt
defaultalg	ext/LinearSolveSparseArraysExt.jl	/^function LinearSolve.defaultalg($/;"	f	module:LinearSolve
defaultalg	ext/LinearSolveSparseArraysExt.jl	/^function LinearSolve.defaultalg(A::AbstractSparseMatrixCSC{Tv, Ti}, b,$/;"	f	module:LinearSolve
defaultalg	src/LinearSolve.jl	/^    function defaultalg(A::SciMLBase.DiffEqArrayOperator, b,$/;"	f
defaultalg	src/default.jl	/^defaultalg(A, b) = defaultalg(A, b, OperatorAssumptions(true))$/;"	f
defaultalg	src/default.jl	/^function defaultalg($/;"	f
defaultalg	src/default.jl	/^function defaultalg(A, b, assump::OperatorAssumptions{Bool})$/;"	f
defaultalg	src/default.jl	/^function defaultalg(A, b, assump::OperatorAssumptions{Nothing})$/;"	f
defaultalg	src/default.jl	/^function defaultalg(A::Bidiagonal, b, ::OperatorAssumptions{Bool})$/;"	f
defaultalg	src/default.jl	/^function defaultalg(A::Diagonal, b, ::OperatorAssumptions{Bool})$/;"	f
defaultalg	src/default.jl	/^function defaultalg(A::Factorization, b, ::OperatorAssumptions{Bool})$/;"	f
defaultalg	src/default.jl	/^function defaultalg(A::GPUArraysCore.AnyGPUArray, b, assump::OperatorAssumptions{Bool})$/;"	f
defaultalg	src/default.jl	/^function defaultalg(A::GPUArraysCore.AnyGPUArray, b::GPUArraysCore.AnyGPUArray,$/;"	f
defaultalg	src/default.jl	/^function defaultalg(A::Hermitian, b, ::OperatorAssumptions{Bool})$/;"	f
defaultalg	src/default.jl	/^function defaultalg(A::MatrixOperator, b,$/;"	f
defaultalg	src/default.jl	/^function defaultalg(A::SMatrix{S1, S2}, b, assump::OperatorAssumptions{Bool}) where {S1, S2}$/;"	f
defaultalg	src/default.jl	/^function defaultalg(A::SciMLOperators.AbstractSciMLOperator, b,$/;"	f
defaultalg	src/default.jl	/^function defaultalg(A::SciMLOperators.AbstractSciMLOperator, b::GPUArraysCore.AnyGPUArray,$/;"	f
defaultalg	src/default.jl	/^function defaultalg(A::SymTridiagonal, b, ::OperatorAssumptions{Bool})$/;"	f
defaultalg	src/default.jl	/^function defaultalg(A::Symmetric{<:Number, <:Array}, b, ::OperatorAssumptions{Bool})$/;"	f
defaultalg	src/default.jl	/^function defaultalg(A::Tridiagonal, b, assump::OperatorAssumptions{Bool})$/;"	f
defaultalg_adjoint_eval	src/default.jl	/^@generated function defaultalg_adjoint_eval(cache::LinearCache, dy)$/;"	f
defaultalg_symbol	src/LinearSolve.jl	/^function defaultalg_symbol end$/;"	f
defaultalg_symbol	src/default.jl	/^defaultalg_symbol(::Type{<:GenericFactorization{typeof(ldlt!)}}) = :LDLtFactorization$/;"	f
defaultalg_symbol	src/default.jl	/^defaultalg_symbol(::Type{<:QRFactorization{ColumnNorm}}) = :QRFactorizationPivoted$/;"	f
defaultalg_symbol	src/default.jl	/^function defaultalg_symbol(::Type{T}) where {T}$/;"	f
do_btf	src/KLU/wrappers.jl	/^    do_btf::Int32$/;"	g	struct:klu_symbolic
do_btf	src/KLU/wrappers.jl	/^    do_btf::Int64$/;"	g	struct:klu_l_symbolic
do_factorization	ext/LinearSolveBandedMatricesExt.jl	/^do_factorization(alg::QRFactorization, A::BandedMatrix, b, u) = alg.inplace ? qr!(A) : qr(A)$/;"	f	module:LinearSolveBandedMatricesExt
do_factorization	ext/LinearSolveBandedMatricesExt.jl	/^function do_factorization(alg::LUFactorization, A::BandedMatrix, b, u)$/;"	f	module:LinearSolveBandedMatricesExt
do_factorization	ext/LinearSolveFastAlmostBandedMatricesExt.jl	/^function do_factorization(alg::QRFactorization, A::AlmostBandedMatrix, b, u)$/;"	f	module:LinearSolveFastAlmostBandedMatricesExt
do_factorization	src/factorization.jl	/^function do_factorization(alg::BunchKaufmanFactorization, A, b, u)$/;"	f
do_factorization	src/factorization.jl	/^function do_factorization(alg::CholeskyFactorization, A, b, u)$/;"	f
do_factorization	src/factorization.jl	/^function do_factorization(alg::GenericFactorization, A, b, u)$/;"	f
do_factorization	src/factorization.jl	/^function do_factorization(alg::LDLtFactorization, A, b, u)$/;"	f
do_factorization	src/factorization.jl	/^function do_factorization(alg::LUFactorization, A, b, u)$/;"	f
do_factorization	src/factorization.jl	/^function do_factorization(alg::QRFactorization, A, b, u)$/;"	f
do_factorization	src/factorization.jl	/^function do_factorization(alg::SVDFactorization, A, b, u)$/;"	f
dparm	src/extension_algs.jl	/^    dparm::Union{Vector{Tuple{Int, Int}}, Nothing}$/;"	g	struct:PardisoJL
eltype	src/preconditioners.jl	/^Base.eltype(A::ComposePreconditioner) = promote_type(eltype(A.inner), eltype(A.outer))$/;"	f	module:Base
eltype	src/preconditioners.jl	/^Base.eltype(A::InvPreconditioner) = Base.eltype(A.P)$/;"	f	module:Base
error_no_cudss_lu	ext/LinearSolveCUDAExt.jl	/^function LinearSolve.error_no_cudss_lu(A::CUDA.CUSPARSE.CuSparseMatrixCSR)$/;"	f	module:LinearSolve
error_no_cudss_lu	src/LinearSolve.jl	/^error_no_cudss_lu(A) = nothing$/;"	f
est_flops	src/KLU/wrappers.jl	/^    est_flops::Cdouble$/;"	g	struct:klu_l_symbolic
est_flops	src/KLU/wrappers.jl	/^    est_flops::Cdouble$/;"	g	struct:klu_symbolic
f	src/KLU/klu.jl	/^        function f(klu)$/;"	f	function:KLU.KLUFactorization.KLUFactorization
f	test/adjoint.jl	/^function f(A, b1; alg = LUFactorization())$/;"	f
f	test/basictests.jl	/^                function f(v, u, p, t)$/;"	f	function:get_operator
f	test/basictests.jl	/^                function f(w, v, u, p, t)$/;"	f	function:get_operator
f	test/nopre/enzyme.jl	/^function f(A, b1, b2; alg = LUFactorization())$/;"	f
f	test/nopre/enzyme.jl	/^function f(A, b1; alg = LUFactorization())$/;"	f
f2	test/nopre/enzyme.jl	/^function f2(A, b1, b2; alg = RFLUFactorization())$/;"	f
f3	test/adjoint.jl	/^function f3(A, b1, b2; alg = KrylovJL_GMRES())$/;"	f
f3	test/nopre/enzyme.jl	/^function f3(A, b1, b2; alg = KrylovJL_GMRES())$/;"	f
f4	test/adjoint.jl	/^function f4(A, b1, b2; alg = LUFactorization())$/;"	f
f4	test/nopre/enzyme.jl	/^function f4(A, b1, b2; alg = LUFactorization())$/;"	f
fA	test/adjoint.jl	/^    function fA(A)$/;"	f
fact_alg	src/factorization.jl	/^    fact_alg::F$/;"	g	struct:GenericFactorization
factors	ext/LinearSolveFastLapackInterfaceExt.jl	/^    factors::F$/;"	g	struct:LinearSolveFastLapackInterfaceExt.WorkspaceAndFactors
fb	test/adjoint.jl	/^    function fb(b)$/;"	f
fbatch	test/nopre/enzyme.jl	/^function fbatch(y, A, b1; alg = LUFactorization())$/;"	f
fdmatrix	benchmarks/sparselu.jl	/^function fdmatrix(N; dim = 2, Tv = Float64, δ = 1.0e-2)$/;"	f
fi	test/basictests.jl	/^                function fi(v, u, p, t)$/;"	f	function:get_operator
fi	test/basictests.jl	/^                function fi(w, v, u, p, t)$/;"	f	function:get_operator
flops	src/KLU/wrappers.jl	/^    flops::Cdouble$/;"	g	struct:klu_common_struct
flops	src/KLU/wrappers.jl	/^    flops::Cdouble$/;"	g	struct:klu_l_common_struct
fnice	test/nopre/enzyme.jl	/^function fnice(A, b, alg)$/;"	f
forward	ext/LinearSolveEnzymeExt.jl	/^function EnzymeRules.forward($/;"	f	module:EnzymeRules
forward	ext/LinearSolveEnzymeExt.jl	/^function EnzymeRules.forward(config::EnzymeRules.FwdConfigWidth{1},$/;"	f	module:EnzymeRules
full	src/factorization.jl	/^    full::Bool$/;"	g	struct:SVDFactorization
g	test/forwarddiff_overloads.jl	/^function g(p)$/;"	f
generate_iterator	src/extension_algs.jl	/^    generate_iterator::F$/;"	g	struct:IterativeSolversJL
generate_probs	test/hypretests.jl	/^function generate_probs(alg)$/;"	f
generic_lufact!	src/generic_lufact.jl	/^     generic_lufact!(args...; kwargs...) = LinearAlgebra.generic_lufact!(args...; kwargs...)$/;"	f
generic_lufact!	src/generic_lufact.jl	/^    function generic_lufact!(A::AbstractMatrix{T}, pivot::Union{RowMaximum,NoPivot,RowNonZero} =/;"	f
getAb	test/hypretests_mpi.jl	/^function getAb(scaling)$/;"	f
get_KrylovJL_solver	src/iterative_wrappers.jl	/^function get_KrylovJL_solver(KrylovAlg)$/;"	f
get_cacheval	src/factorization.jl	/^macro get_cacheval(cache, algsym)$/;"	m
get_operator	test/basictests.jl	/^            function get_operator(A, u; add_inverse = true)$/;"	f
getcolptr	src/LinearSolve.jl	/^getcolptr(A) = error("SparseArrays extension not loaded")$/;"	f	module:LinearSolve
getcolptr	test/basictests.jl	/^    SparseArrays.getcolptr(m::MySparseMatrixCSC) = SparseArrays.getcolptr(m.csc)$/;"	f	module:SparseArrays
getcolptr	test/pardiso/pardiso.jl	/^    SparseArrays.getcolptr(m::MySparseMatrixCSC2) = SparseArrays.getcolptr(m.csc)$/;"	f	module:SparseArrays
getproperty	src/KLU/klu.jl	/^function getproperty(klu::AbstractKLUFactorization{Tv, Ti},$/;"	f
getrf!	src/mkl.jl	/^function getrf!(A::AbstractMatrix{<:ComplexF32};$/;"	f
getrf!	src/mkl.jl	/^function getrf!(A::AbstractMatrix{<:ComplexF64};$/;"	f
getrf!	src/mkl.jl	/^function getrf!(A::AbstractMatrix{<:Float32};$/;"	f
getrf!	src/mkl.jl	/^function getrf!(A::AbstractMatrix{<:Float64};$/;"	f
getrs!	src/mkl.jl	/^function getrs!(trans::AbstractChar,$/;"	f
global	src/appleaccelerate.jl	/^const global libacc = "\/System\/Library\/Frameworks\/Accelerate.framework\/Accelerate"$/;"	c
gmres_restart	src/extension_algs.jl	/^    gmres_restart::I$/;"	g	struct:IterativeSolversJL
gmres_restart	src/extension_algs.jl	/^    gmres_restart::I$/;"	g	struct:KrylovKitJL
gmres_restart	src/iterative_wrappers.jl	/^    gmres_restart::I$/;"	g	struct:KrylovJL
grad_sparse	test/sparse_vector.jl	/^function grad_sparse(x::Vector{T}) where {T <: Number}$/;"	f
h	test/forwarddiff_overloads.jl	/^function h(p)$/;"	f
halt_if_singular	src/KLU/wrappers.jl	/^    halt_if_singular::Cint$/;"	g	struct:klu_common_struct
halt_if_singular	src/KLU/wrappers.jl	/^    halt_if_singular::Cint$/;"	g	struct:klu_l_common_struct
handle_sparsematrixcsc_lu	ext/LinearSolveSparseArraysExt.jl	/^function LinearSolve.handle_sparsematrixcsc_lu(A::AbstractSparseMatrixCSC)$/;"	f	module:LinearSolve
handle_sparsematrixcsc_lu	src/LinearSolve.jl	/^handle_sparsematrixcsc_lu(A) = lu(A)$/;"	f	module:LinearSolve
hess_sparse	test/sparse_vector.jl	/^function hess_sparse(x::Vector{T}) where {T}$/;"	f
inactive_type	ext/LinearSolveEnzymeExt.jl	/^@inline EnzymeCore.EnzymeRules.inactive_type(::Type{<:LinearSolve.SciMLLinearSolveAlgorithm}) = /;"	f	module:EnzymeRules
increment	src/KLU/klu.jl	/^increment(A::AbstractArray{<:Integer}) = increment!(copy(A))$/;"	f	module:KLU
increment!	src/KLU/klu.jl	/^function increment!(A::AbstractArray{T}) where {T <: Integer}$/;"	f	module:KLU
info	src/simplelu.jl	/^    info::Int$/;"	g	struct:LUSolver
init	ext/LinearSolveHYPREExt.jl	/^function SciMLBase.init(prob::LinearProblem, alg::HYPREAlgorithm,$/;"	f	module:SciMLBase
init	src/common.jl	/^function SciMLBase.init(prob::LinearProblem, alg::SciMLLinearSolveAlgorithm,$/;"	f	module:SciMLBase
init	src/common.jl	/^function SciMLBase.init(prob::LinearProblem, args...; kwargs...)$/;"	f	module:SciMLBase
init	src/default.jl	/^function SciMLBase.init(prob::LinearProblem, alg::Nothing,$/;"	f	module:SciMLBase
init_cacheval	ext/LinearSolveBandedMatricesExt.jl	/^        function init_cacheval(::$(alg), ::BandedMatrix, b, u, Pl, Pr, maxiters::Int,$/;"	f	module:LinearSolveBandedMatricesExt
init_cacheval	ext/LinearSolveBandedMatricesExt.jl	/^        function init_cacheval(::$(alg), ::Symmetric{<:Number, <:BandedMatrix}, b, u, Pl,$/;"	f	module:LinearSolveBandedMatricesExt
init_cacheval	ext/LinearSolveBandedMatricesExt.jl	/^function init_cacheval(::LUFactorization, A::BandedMatrix{T}, b, u, Pl, Pr, maxiters::Int,$/;"	f	module:LinearSolveBandedMatricesExt
init_cacheval	ext/LinearSolveBlockDiagonalsExt.jl	/^function LinearSolve.init_cacheval(alg::SimpleGMRES{false}, A::BlockDiagonal, b, args...;$/;"	f	module:LinearSolve
init_cacheval	ext/LinearSolveCUDAExt.jl	/^function LinearSolve.init_cacheval($/;"	f	module:LinearSolve
init_cacheval	ext/LinearSolveCUDAExt.jl	/^function LinearSolve.init_cacheval(alg::CudaOffloadFactorization, A, b, u, Pl, Pr,$/;"	f	module:LinearSolve
init_cacheval	ext/LinearSolveFastAlmostBandedMatricesExt.jl	/^        function init_cacheval(::$(alg), ::AlmostBandedMatrix, b, u, Pl, Pr, maxiters::Int,$/;"	f	module:LinearSolveFastAlmostBandedMatricesExt
init_cacheval	ext/LinearSolveFastLapackInterfaceExt.jl	/^function LinearSolve.init_cacheval($/;"	f	module:LinearSolve
init_cacheval	ext/LinearSolveFastLapackInterfaceExt.jl	/^function LinearSolve.init_cacheval(::FastLUFactorization, A, b, u, Pl, Pr,$/;"	f	module:LinearSolve
init_cacheval	ext/LinearSolveFastLapackInterfaceExt.jl	/^function LinearSolve.init_cacheval(alg::FastQRFactorization, A, b, u, Pl, Pr,$/;"	f	module:LinearSolve
init_cacheval	ext/LinearSolveHYPREExt.jl	/^function LinearSolve.init_cacheval(alg::HYPREAlgorithm, A, b, u, Pl, Pr, maxiters::Int,$/;"	f	module:LinearSolve
init_cacheval	ext/LinearSolveIterativeSolversExt.jl	/^function LinearSolve.init_cacheval(alg::IterativeSolversJL, A, b, u, Pl, Pr, maxiters::Int,$/;"	f	module:LinearSolve
init_cacheval	ext/LinearSolveMetalExt.jl	/^function LinearSolve.init_cacheval(alg::MetalLUFactorization, A, b, u, Pl, Pr,$/;"	f	module:LinearSolve
init_cacheval	ext/LinearSolvePardisoExt.jl	/^function LinearSolve.init_cacheval(alg::PardisoJL,$/;"	f	module:LinearSolve
init_cacheval	ext/LinearSolveSparseArraysExt.jl	/^function LinearSolve.init_cacheval($/;"	f	module:LinearSolve
init_cacheval	ext/LinearSolveSparseArraysExt.jl	/^function LinearSolve.init_cacheval(alg::CHOLMODFactorization,$/;"	f	module:LinearSolve
init_cacheval	ext/LinearSolveSparseArraysExt.jl	/^function LinearSolve.init_cacheval(alg::GenericFactorization,$/;"	f	module:LinearSolve
init_cacheval	ext/LinearSolveSparseArraysExt.jl	/^function LinearSolve.init_cacheval(alg::NormalCholeskyFactorization,$/;"	f	module:LinearSolve
init_cacheval	ext/LinearSolveSparseArraysExt.jl	/^function LinearSolve.init_cacheval(alg::QRFactorization, A::SparseMatrixCSC{Float64, <:Integer},/;"	f	module:LinearSolve
init_cacheval	ext/LinearSolveSparseArraysExt.jl	/^function LinearSolve.init_cacheval(alg::RFLUFactorization,$/;"	f	module:LinearSolve
init_cacheval	ext/LinearSolveSparspakExt.jl	/^function LinearSolve.init_cacheval($/;"	f	module:LinearSolve
init_cacheval	src/appleaccelerate.jl	/^function LinearSolve.init_cacheval(alg::AppleAccelerateLUFactorization, A, b, u, Pl, Pr,$/;"	f	module:LinearSolve
init_cacheval	src/appleaccelerate.jl	/^function LinearSolve.init_cacheval(alg::AppleAccelerateLUFactorization,$/;"	f	module:LinearSolve
init_cacheval	src/common.jl	/^init_cacheval(alg::SciMLLinearSolveAlgorithm, args...) = nothing$/;"	f
init_cacheval	src/default.jl	/^@generated function init_cacheval(alg::DefaultLinearSolver, A, b, u, Pl, Pr, maxiters::Int,$/;"	f
init_cacheval	src/default.jl	/^function init_cacheval(alg::Nothing, A, b, u, Pl, Pr, maxiters::Int, abstol, reltol,$/;"	f
init_cacheval	src/factorization.jl	/^    @eval function init_cacheval(alg::$alg, A::MatrixOperator, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function LinearSolve.init_cacheval($/;"	f	module:LinearSolve
init_cacheval	src/factorization.jl	/^function LinearSolve.init_cacheval(alg::RFLUFactorization, A, b, u, Pl, Pr, maxiters::Int,$/;"	f	module:LinearSolve
init_cacheval	src/factorization.jl	/^function LinearSolve.init_cacheval(alg::RFLUFactorization,$/;"	f	module:LinearSolve
init_cacheval	src/factorization.jl	/^function init_cacheval($/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(::SparspakFactorization, ::StaticArray, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::AbstractFactorization, A, b, u, Pl, Pr, maxiters::Int, abstol,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::BunchKaufmanFactorization, A, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::BunchKaufmanFactorization, A::Symmetric{<:Number, <:Matrix}, b,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::BunchKaufmanFactorization,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::CHOLMODFactorization,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::CholeskyFactorization, A::GPUArraysCore.AnyGPUArray, b, u, Pl,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::CholeskyFactorization, A::Matrix{Float64}, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::CholeskyFactorization, A::SMatrix{S1, S2}, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::CholeskyFactorization,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::DiagonalFactorization, A, b, u, Pl, Pr, maxiters::Int,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericFactorization, A, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericFactorization, A::AbstractMatrix, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericFactorization, A::Diagonal, b, u, Pl, Pr, maxiters::Int,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericFactorization, A::SymTridiagonal{T, V}, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericFactorization, A::Tridiagonal, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericFactorization{typeof(cholesky!)},$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericFactorization{typeof(cholesky)},$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericFactorization{typeof(lu!)}, A::Diagonal, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericFactorization{typeof(lu!)},$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericFactorization{typeof(lu)}, A::Diagonal, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericFactorization{typeof(lu)}, A::Tridiagonal, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericFactorization{typeof(lu)},$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericFactorization{typeof(qr!)}, A::Diagonal, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericFactorization{typeof(qr!)},$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericFactorization{typeof(qr)}, A::Diagonal, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericFactorization{typeof(qr)}, A::Tridiagonal, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericFactorization{typeof(qr)},$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericFactorization{typeof(svd!)}, A::Diagonal, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericFactorization{typeof(svd!)}, A::Tridiagonal, b, u, Pl,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericFactorization{typeof(svd!)},$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericFactorization{typeof(svd)}, A::Diagonal, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericFactorization{typeof(svd)},$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::GenericLUFactorization,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::KLUFactorization,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::LDLtFactorization, A, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::LDLtFactorization, A::SymTridiagonal, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::LUFactorization,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::NormalBunchKaufmanFactorization, A, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::NormalCholeskyFactorization, A, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::NormalCholeskyFactorization, A::Matrix{Float64}, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::NormalCholeskyFactorization, A::SMatrix, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::NormalCholeskyFactorization,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::QRFactorization, A, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::QRFactorization, A::AbstractSciMLOperator, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::QRFactorization, A::Symmetric{<:Number, <:Array}, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::QRFactorization{ColumnNorm}, A::Matrix{Float64}, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::QRFactorization{NoPivot}, A::Matrix{Float64}, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::SVDFactorization, A, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::SVDFactorization, A::Matrix{Float64}, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::SVDFactorization, A::Union{Matrix, SMatrix}, b, u, Pl, Pr,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::SparspakFactorization,$/;"	f
init_cacheval	src/factorization.jl	/^function init_cacheval(alg::UMFPACKFactorization,$/;"	f
init_cacheval	src/iterative_wrappers.jl	/^function init_cacheval($/;"	f
init_cacheval	src/iterative_wrappers.jl	/^function init_cacheval(alg::KrylovJL, A, b, u, Pl, Pr, maxiters::Int, abstol, reltol,$/;"	f
init_cacheval	src/mkl.jl	/^function LinearSolve.init_cacheval(alg::MKLLUFactorization, A, b, u, Pl, Pr,$/;"	f	module:LinearSolve
init_cacheval	src/mkl.jl	/^function LinearSolve.init_cacheval(alg::MKLLUFactorization,$/;"	f	module:LinearSolve
init_cacheval	src/simplegmres.jl	/^function init_cacheval(alg::SimpleGMRES{UDB}, args...; kwargs...) where {UDB}$/;"	f
init_cacheval	src/simplelu.jl	/^function init_cacheval(alg::SimpleLUFactorization, A, b, u, Pl, Pr, maxiters::Int, abstol,$/;"	f
initmem	src/KLU/wrappers.jl	/^    initmem::Cdouble$/;"	g	struct:klu_common_struct
initmem	src/KLU/wrappers.jl	/^    initmem::Cdouble$/;"	g	struct:klu_l_common_struct
initmem_amd	src/KLU/wrappers.jl	/^    initmem_amd::Cdouble$/;"	g	struct:klu_common_struct
initmem_amd	src/KLU/wrappers.jl	/^    initmem_amd::Cdouble$/;"	g	struct:klu_l_common_struct
inner	src/preconditioners.jl	/^    inner::Ti$/;"	g	struct:ComposePreconditioner
inplace	src/factorization.jl	/^    inplace::Bool$/;"	g	struct:QRFactorization
iparm	src/extension_algs.jl	/^    iparm::Union{Vector{Tuple{Int, Int}}, Nothing}$/;"	g	struct:PardisoJL
is_cusparse	ext/LinearSolveCUDAExt.jl	/^function LinearSolve.is_cusparse(A::Union{CUDA.CUSPARSE.CuSparseMatrixCSR, CUDA.CUSPARSE.CuSpars/;"	f	module:LinearSolve
is_cusparse	src/LinearSolve.jl	/^is_cusparse(A) = false$/;"	f
is_underdetermined	src/LinearSolve.jl	/^is_underdetermined(A::AbstractMatrix) = size(A, 1) < size(A, 2)$/;"	f	module:LinearSolve
is_underdetermined	src/LinearSolve.jl	/^is_underdetermined(A::AbstractSciMLOperator) = size(A, 1) < size(A, 2)$/;"	f	module:LinearSolve
is_underdetermined	src/LinearSolve.jl	/^is_underdetermined(x) = false$/;"	f	module:LinearSolve
isfresh	src/common.jl	/^    isfresh::Bool # false => cacheval is set wrt A, true => update cacheval wrt A$/;"	g	struct:LinearCache
isfresh_A	ext/LinearSolveHYPREExt.jl	/^    isfresh_A::Bool$/;"	g	struct:LinearSolveHYPREExt.HYPRECache
isfresh_b	ext/LinearSolveHYPREExt.jl	/^    isfresh_b::Bool$/;"	g	struct:LinearSolveHYPREExt.HYPRECache
isfresh_u	ext/LinearSolveHYPREExt.jl	/^    isfresh_u::Bool$/;"	g	struct:LinearSolveHYPREExt.HYPRECache
isok	src/KLU/klu.jl	/^macro isok(A)$/;"	m	module:KLU
isopenblas	src/LinearSolve.jl	/^isopenblas() = IS_OPENBLAS[]$/;"	f
issparsematrix	ext/LinearSolveSparseArraysExt.jl	/^LinearSolve.issparsematrix(A::AbstractSparseArray) = true$/;"	f	module:LinearSolve
issparsematrix	src/LinearSolve.jl	/^issparsematrix(A) = false$/;"	f	module:LinearSolve
issparsematrixcsc	ext/LinearSolveSparseArraysExt.jl	/^LinearSolve.issparsematrixcsc(A::AbstractSparseMatrixCSC) = true$/;"	f	module:LinearSolve
issparsematrixcsc	src/LinearSolve.jl	/^issparsematrixcsc(A) = false$/;"	f	module:LinearSolve
issq	src/common.jl	/^    issq::T$/;"	g	struct:OperatorAssumptions
issuccess	src/KLU/klu.jl	/^function LinearAlgebra.issuccess(K::AbstractKLUFactorization; allowsingular = false)$/;"	f	module:LinearAlgebra
klu	src/KLU/klu.jl	/^function klu(A::SparseMatrixCSC{Tv, Ti}; check = true,$/;"	f
klu	src/KLU/klu.jl	/^function klu(n, colptr::Vector{Ti}, rowval::Vector{Ti}, nzval::Vector{Tv}; check = true,$/;"	f
klu!	src/KLU/klu.jl	/^        function klu!(K::KLUFactorization{$Tv, $Ti}, nzval::Vector{$Tv};$/;"	f
klu!	src/KLU/klu.jl	/^function klu!(K::AbstractKLUFactorization{ComplexF64}, nzval::Vector{U};$/;"	f
klu!	src/KLU/klu.jl	/^function klu!(K::AbstractKLUFactorization{Float64}, nzval::Vector{U};$/;"	f
klu!	src/KLU/klu.jl	/^function klu!(K::KLUFactorization{U}, S::SparseMatrixCSC{U};$/;"	f
klu_analyze	src/KLU/wrappers.jl	/^function klu_analyze(n, Ap, Ai, Common)$/;"	f
klu_analyze!	src/KLU/klu.jl	/^function klu_analyze!(K::KLUFactorization{Tv, Ti}, P::Vector{Ti},$/;"	f
klu_analyze!	src/KLU/klu.jl	/^function klu_analyze!(K::KLUFactorization{Tv, Ti}; check = true) where {Tv, Ti <: KLUITypes}$/;"	f
klu_analyze_given	src/KLU/wrappers.jl	/^function klu_analyze_given(n, Ap, Ai, P, Q, Common)$/;"	f
klu_common	src/KLU/wrappers.jl	/^const klu_common = klu_common_struct$/;"	c
klu_common_struct	src/KLU/wrappers.jl	/^    klu_common_struct() = new()$/;"	f	struct:klu_common_struct
klu_common_struct	src/KLU/wrappers.jl	/^mutable struct klu_common_struct$/;"	s
klu_condest	src/KLU/wrappers.jl	/^function klu_condest(Ap, Ax, Symbolic, Numeric, Common)$/;"	f
klu_defaults	src/KLU/wrappers.jl	/^function klu_defaults(Common)$/;"	f
klu_extract	src/KLU/wrappers.jl	/^function klu_extract($/;"	f
klu_factor	src/KLU/wrappers.jl	/^function klu_factor(Ap, Ai, Ax, Symbolic, Common)$/;"	f
klu_factor!	src/KLU/klu.jl	/^        function klu_factor!($/;"	f
klu_flops	src/KLU/wrappers.jl	/^function klu_flops(Symbolic, Numeric, Common)$/;"	f
klu_free	src/KLU/wrappers.jl	/^function klu_free(p, n, size, Common)$/;"	f
klu_free_numeric	src/KLU/wrappers.jl	/^function klu_free_numeric(Numeric, Common)$/;"	f
klu_free_symbolic	src/KLU/wrappers.jl	/^function klu_free_symbolic(Symbolic, Common)$/;"	f
klu_l_analyze	src/KLU/wrappers.jl	/^function klu_l_analyze(arg1, arg2, arg3, Common)$/;"	f
klu_l_analyze_given	src/KLU/wrappers.jl	/^function klu_l_analyze_given(arg1, arg2, arg3, arg4, arg5, arg6)$/;"	f
klu_l_common	src/KLU/wrappers.jl	/^const klu_l_common = klu_l_common_struct$/;"	c
klu_l_common_struct	src/KLU/wrappers.jl	/^    klu_l_common_struct() = new()$/;"	f	struct:klu_l_common_struct
klu_l_common_struct	src/KLU/wrappers.jl	/^mutable struct klu_l_common_struct$/;"	s
klu_l_condest	src/KLU/wrappers.jl	/^function klu_l_condest(arg1, arg2, arg3, arg4, arg5)$/;"	f
klu_l_defaults	src/KLU/wrappers.jl	/^function klu_l_defaults(Common)$/;"	f
klu_l_extract	src/KLU/wrappers.jl	/^function klu_l_extract(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9,$/;"	f
klu_l_factor	src/KLU/wrappers.jl	/^function klu_l_factor(arg1, arg2, arg3, arg4, arg5)$/;"	f
klu_l_flops	src/KLU/wrappers.jl	/^function klu_l_flops(arg1, arg2, arg3)$/;"	f
klu_l_free	src/KLU/wrappers.jl	/^function klu_l_free(arg1, arg2, arg3, arg4)$/;"	f
klu_l_free_numeric	src/KLU/wrappers.jl	/^function klu_l_free_numeric(arg1, arg2)$/;"	f
klu_l_free_symbolic	src/KLU/wrappers.jl	/^function klu_l_free_symbolic(arg1, arg2)$/;"	f
klu_l_malloc	src/KLU/wrappers.jl	/^function klu_l_malloc(arg1, arg2, arg3)$/;"	f
klu_l_numeric	src/KLU/wrappers.jl	/^    klu_l_numeric() = new()$/;"	f	struct:klu_l_numeric
klu_l_numeric	src/KLU/wrappers.jl	/^mutable struct klu_l_numeric$/;"	s
klu_l_rcond	src/KLU/wrappers.jl	/^function klu_l_rcond(arg1, arg2, arg3)$/;"	f
klu_l_realloc	src/KLU/wrappers.jl	/^function klu_l_realloc(arg1, arg2, arg3, arg4, arg5)$/;"	f
klu_l_refactor	src/KLU/wrappers.jl	/^function klu_l_refactor(arg1, arg2, arg3, arg4, arg5, arg6)$/;"	f
klu_l_rgrowth	src/KLU/wrappers.jl	/^function klu_l_rgrowth(arg1, arg2, arg3, arg4, arg5, arg6)$/;"	f
klu_l_scale	src/KLU/wrappers.jl	/^function klu_l_scale(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)$/;"	f
klu_l_solve	src/KLU/wrappers.jl	/^function klu_l_solve(arg1, arg2, arg3, arg4, arg5, arg6)$/;"	f
klu_l_sort	src/KLU/wrappers.jl	/^function klu_l_sort(arg1, arg2, arg3)$/;"	f
klu_l_symbolic	src/KLU/wrappers.jl	/^    klu_l_symbolic() = new()$/;"	f	struct:klu_l_symbolic
klu_l_symbolic	src/KLU/wrappers.jl	/^mutable struct klu_l_symbolic$/;"	s
klu_l_tsolve	src/KLU/wrappers.jl	/^function klu_l_tsolve(arg1, arg2, arg3, arg4, arg5, arg6)$/;"	f
klu_malloc	src/KLU/wrappers.jl	/^function klu_malloc(n, size, Common)$/;"	f
klu_numeric	src/KLU/wrappers.jl	/^    klu_numeric() = new()$/;"	f	struct:klu_numeric
klu_numeric	src/KLU/wrappers.jl	/^mutable struct klu_numeric$/;"	s
klu_rcond	src/KLU/wrappers.jl	/^function klu_rcond(Symbolic, Numeric, Common)$/;"	f
klu_realloc	src/KLU/wrappers.jl	/^function klu_realloc(nnew, nold, size, p, Common)$/;"	f
klu_refactor	src/KLU/wrappers.jl	/^function klu_refactor(Ap, Ai, Ax, Symbolic, Numeric, Common)$/;"	f
klu_rgrowth	src/KLU/wrappers.jl	/^function klu_rgrowth(Ap, Ai, Ax, Symbolic, Numeric, Common)$/;"	f
klu_scale	src/KLU/wrappers.jl	/^function klu_scale(scale, n, Ap, Ai, Ax, Rs, W, Common)$/;"	f
klu_solve	src/KLU/wrappers.jl	/^function klu_solve(Symbolic, Numeric, ldim, nrhs, B, Common)$/;"	f
klu_sort	src/KLU/wrappers.jl	/^function klu_sort(Symbolic, Numeric, Common)$/;"	f
klu_symbolic	src/KLU/wrappers.jl	/^    klu_symbolic() = new()$/;"	f	struct:klu_symbolic
klu_symbolic	src/KLU/wrappers.jl	/^mutable struct klu_symbolic$/;"	s
klu_tsolve	src/KLU/wrappers.jl	/^function klu_tsolve(Symbolic, Numeric, ldim, nrhs, B, Common)$/;"	f
klu_z_condest	src/KLU/wrappers.jl	/^function klu_z_condest(Ap, Ax, Symbolic, Numeric, Common)$/;"	f
klu_z_extract	src/KLU/wrappers.jl	/^function klu_z_extract(Numeric, Symbolic, Lp, Li, Lx, Lz, Up, Ui,$/;"	f
klu_z_factor	src/KLU/wrappers.jl	/^function klu_z_factor(Ap, Ai, Ax, Symbolic, Common)$/;"	f
klu_z_flops	src/KLU/wrappers.jl	/^function klu_z_flops(Symbolic, Numeric, Common)$/;"	f
klu_z_free_numeric	src/KLU/wrappers.jl	/^function klu_z_free_numeric(Numeric, Common)$/;"	f
klu_z_rcond	src/KLU/wrappers.jl	/^function klu_z_rcond(Symbolic, Numeric, Common)$/;"	f
klu_z_refactor	src/KLU/wrappers.jl	/^function klu_z_refactor(Ap, Ai, Ax, Symbolic, Numeric, Common)$/;"	f
klu_z_rgrowth	src/KLU/wrappers.jl	/^function klu_z_rgrowth(Ap, Ai, Ax, Symbolic, Numeric, Common)$/;"	f
klu_z_scale	src/KLU/wrappers.jl	/^function klu_z_scale(scale, n, Ap, Ai, Ax, Rs, W, Common)$/;"	f
klu_z_solve	src/KLU/wrappers.jl	/^function klu_z_solve(Symbolic, Numeric, ldim, nrhs, B, Common)$/;"	f
klu_z_sort	src/KLU/wrappers.jl	/^function klu_z_sort(Symbolic, Numeric, Common)$/;"	f
klu_z_tsolve	src/KLU/wrappers.jl	/^function klu_z_tsolve(Symbolic, Numeric, ldim, nrhs, B, conj_solve, Common)$/;"	f
klu_zl_condest	src/KLU/wrappers.jl	/^function klu_zl_condest(arg1, arg2, arg3, arg4, arg5)$/;"	f
klu_zl_extract	src/KLU/wrappers.jl	/^function klu_zl_extract(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10,$/;"	f
klu_zl_factor	src/KLU/wrappers.jl	/^function klu_zl_factor(arg1, arg2, arg3, arg4, arg5)$/;"	f
klu_zl_flops	src/KLU/wrappers.jl	/^function klu_zl_flops(arg1, arg2, arg3)$/;"	f
klu_zl_free_numeric	src/KLU/wrappers.jl	/^function klu_zl_free_numeric(arg1, arg2)$/;"	f
klu_zl_rcond	src/KLU/wrappers.jl	/^function klu_zl_rcond(arg1, arg2, arg3)$/;"	f
klu_zl_refactor	src/KLU/wrappers.jl	/^function klu_zl_refactor(arg1, arg2, arg3, arg4, arg5, arg6)$/;"	f
klu_zl_rgrowth	src/KLU/wrappers.jl	/^function klu_zl_rgrowth(arg1, arg2, arg3, arg4, arg5, arg6)$/;"	f
klu_zl_scale	src/KLU/wrappers.jl	/^function klu_zl_scale(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)$/;"	f
klu_zl_solve	src/KLU/wrappers.jl	/^function klu_zl_solve(arg1, arg2, arg3, arg4, arg5, arg6)$/;"	f
klu_zl_sort	src/KLU/wrappers.jl	/^function klu_zl_sort(arg1, arg2, arg3)$/;"	f
klu_zl_tsolve	src/KLU/wrappers.jl	/^function klu_zl_tsolve(arg1, arg2, arg3, arg4, arg5, arg6, arg7)$/;"	f
kluerror	src/KLU/klu.jl	/^function kluerror(status::Integer)$/;"	f	module:KLU
kluerror	src/KLU/klu.jl	/^kluerror(common::Union{klu_l_common, klu_common}) = kluerror(common.status)$/;"	f	module:KLU
kwargs	src/extension_algs.jl	/^    kwargs::K$/;"	g	struct:IterativeSolversJL
kwargs	src/extension_algs.jl	/^    kwargs::K$/;"	g	struct:KrylovKitJL
kwargs	src/iterative_wrappers.jl	/^    kwargs::K$/;"	g	struct:KrylovJL
lattice	benchmarks/sparselu.jl	/^function lattice(n; Tv = Float64)$/;"	f
lattice	benchmarks/sparselu.jl	/^lattice(L...; Tv = Float64) = lattice(L[1]; Tv) ⊕ lattice(L[2:end]...; Tv)$/;"	f
ldiv!	src/KLU/klu.jl	/^function LinearAlgebra.ldiv!($/;"	f	module:LinearAlgebra
ldiv!	src/KLU/klu.jl	/^function LinearAlgebra.ldiv!(klu::Union{AdjointFact{Tv, K}, TransposeFact{Tv, K}},$/;"	f	module:LinearAlgebra
ldiv!	src/preconditioners.jl	/^LinearAlgebra.ldiv!(A::InvPreconditioner, x) = mul!(x, A.P, x)$/;"	f	module:LinearAlgebra
ldiv!	src/preconditioners.jl	/^LinearAlgebra.ldiv!(y, A::InvPreconditioner, x) = mul!(y, A.P, x)$/;"	f	module:LinearAlgebra
ldiv!	src/preconditioners.jl	/^function LinearAlgebra.ldiv!(A::ComposePreconditioner, x)$/;"	f	module:LinearAlgebra
ldiv!	src/preconditioners.jl	/^function LinearAlgebra.ldiv!(y, A::ComposePreconditioner, x)$/;"	f	module:LinearAlgebra
libklu	src/KLU/klu.jl	/^const libklu = :libklu$/;"	c	module:KLU
libsuitesparseconfig	src/KLU/klu.jl	/^const libsuitesparseconfig = :libsuitesparseconfig$/;"	c	module:KLU
linprob_f	test/forwarddiff_overloads.jl	/^function linprob_f(p)$/;"	f
linprob_f_hes	test/forwarddiff_overloads.jl	/^function linprob_f_hes(p)$/;"	f
linsolve	src/adjoint.jl	/^    linsolve::L = missing$/;"	g	struct:LinearSolveAdjoint
lnz	src/KLU/wrappers.jl	/^    lnz::Cdouble$/;"	g	struct:klu_l_symbolic
lnz	src/KLU/wrappers.jl	/^    lnz::Cdouble$/;"	g	struct:klu_symbolic
lnz	src/KLU/wrappers.jl	/^    lnz::Int32$/;"	g	struct:klu_numeric
lnz	src/KLU/wrappers.jl	/^    lnz::Int64$/;"	g	struct:klu_l_numeric
luflop	benchmarks/applelu.jl	/^function luflop(m, n = m; innerflop = 2)$/;"	f
luflop	benchmarks/cudalu.jl	/^function luflop(m, n = m; innerflop = 2)$/;"	f
luflop	benchmarks/lu.jl	/^function luflop(m, n = m; innerflop = 2)$/;"	f
luflop	benchmarks/metallu.jl	/^function luflop(m, n = m; innerflop = 2)$/;"	f
makeA	test/pardiso/pardiso.jl	/^function makeA()$/;"	f
make_SparseMatrixCSC	ext/LinearSolveSparseArraysExt.jl	/^function LinearSolve.make_SparseMatrixCSC(A::AbstractSparseArray)$/;"	f	module:LinearSolve
make_SparseMatrixCSC	src/LinearSolve.jl	/^make_SparseMatrixCSC(A) = nothing$/;"	f	module:LinearSolve
makeempty_SparseMatrixCSC	ext/LinearSolveSparseArraysExt.jl	/^function LinearSolve.makeempty_SparseMatrixCSC(A::AbstractSparseArray)$/;"	f	module:LinearSolve
makeempty_SparseMatrixCSC	src/LinearSolve.jl	/^makeempty_SparseMatrixCSC(A) = nothing$/;"	f	module:LinearSolve
matrix_type	src/extension_algs.jl	/^    matrix_type::T2$/;"	g	struct:PardisoJL
max_lnz_block	src/KLU/wrappers.jl	/^    max_lnz_block::Int32$/;"	g	struct:klu_numeric
max_lnz_block	src/KLU/wrappers.jl	/^    max_lnz_block::Int64$/;"	g	struct:klu_l_numeric
max_unz_block	src/KLU/wrappers.jl	/^    max_unz_block::Int32$/;"	g	struct:klu_numeric
max_unz_block	src/KLU/wrappers.jl	/^    max_unz_block::Int64$/;"	g	struct:klu_l_numeric
maxblock	src/KLU/wrappers.jl	/^    maxblock::Int32$/;"	g	struct:klu_symbolic
maxblock	src/KLU/wrappers.jl	/^    maxblock::Int64$/;"	g	struct:klu_l_symbolic
maxiters	src/common.jl	/^    maxiters::Int$/;"	g	struct:LinearCache
maxiters	src/simplegmres.jl	/^    maxiters::Int$/;"	g	struct:SimpleGMRESCache
maxwork	src/KLU/wrappers.jl	/^    maxwork::Cdouble$/;"	g	struct:klu_common_struct
maxwork	src/KLU/wrappers.jl	/^    maxwork::Cdouble$/;"	g	struct:klu_l_common_struct
memgrow	src/KLU/wrappers.jl	/^    memgrow::Cdouble$/;"	g	struct:klu_common_struct
memgrow	src/KLU/wrappers.jl	/^    memgrow::Cdouble$/;"	g	struct:klu_l_common_struct
memory	src/simplegmres.jl	/^    memory::Int$/;"	g	struct:SimpleGMRES
memory	src/simplegmres.jl	/^    memory::Int$/;"	g	struct:SimpleGMRESCache
mempeak	src/KLU/wrappers.jl	/^    mempeak::Csize_t$/;"	g	struct:klu_common_struct
mempeak	src/KLU/wrappers.jl	/^    mempeak::Csize_t$/;"	g	struct:klu_l_common_struct
memusage	src/KLU/wrappers.jl	/^    memusage::Csize_t$/;"	g	struct:klu_common_struct
memusage	src/KLU/wrappers.jl	/^    memusage::Csize_t$/;"	g	struct:klu_l_common_struct
mul!	src/preconditioners.jl	/^LinearAlgebra.mul!(y, A::InvPreconditioner, x) = ldiv!(y, A.P, x)$/;"	f	module:LinearAlgebra
n	src/KLU/klu.jl	/^    n::Int$/;"	g	struct:KLU.KLUFactorization
n	src/KLU/wrappers.jl	/^    n::Int32$/;"	g	struct:klu_numeric
n	src/KLU/wrappers.jl	/^    n::Int32$/;"	g	struct:klu_symbolic
n	src/KLU/wrappers.jl	/^    n::Int64$/;"	g	struct:klu_l_numeric
n	src/KLU/wrappers.jl	/^    n::Int64$/;"	g	struct:klu_l_symbolic
n	src/simplegmres.jl	/^    n::Int$/;"	g	struct:SimpleGMRESCache
n	src/simplelu.jl	/^    n::Int$/;"	g	struct:LUSolver
nblocks	src/KLU/wrappers.jl	/^    nblocks::Int32$/;"	g	struct:klu_numeric
nblocks	src/KLU/wrappers.jl	/^    nblocks::Int32$/;"	g	struct:klu_symbolic
nblocks	src/KLU/wrappers.jl	/^    nblocks::Int64$/;"	g	struct:klu_l_numeric
nblocks	src/KLU/wrappers.jl	/^    nblocks::Int64$/;"	g	struct:klu_l_symbolic
needs_concrete_A	ext/LinearSolvePardisoExt.jl	/^LinearSolve.needs_concrete_A(alg::PardisoJL) = true$/;"	f	module:LinearSolve
needs_concrete_A	src/LinearSolve.jl	/^needs_concrete_A(alg::AbstractFactorization) = true$/;"	f	module:LinearSolve
needs_concrete_A	src/LinearSolve.jl	/^needs_concrete_A(alg::AbstractKrylovSubspaceMethod) = false$/;"	f	module:LinearSolve
needs_concrete_A	src/LinearSolve.jl	/^needs_concrete_A(alg::AbstractSolveFunction) = false$/;"	f	module:LinearSolve
needs_concrete_A	src/LinearSolve.jl	/^needs_concrete_A(alg::AbstractSparseFactorization) = true$/;"	f	module:LinearSolve
needs_concrete_A	src/default.jl	/^needs_concrete_A(alg::DefaultLinearSolver) = true$/;"	f
needs_square_A	src/LinearSolve.jl	/^    @eval needs_square_A(::$(alg)) = false$/;"	f
needs_square_A	src/LinearSolve.jl	/^    @eval needs_square_A(::$(alg)) = true$/;"	f
needs_square_A	src/LinearSolve.jl	/^    @eval needs_square_A(::KrylovJL{$(typeof(kralg))}) = false$/;"	f
needs_square_A	src/LinearSolve.jl	/^needs_square_A(::Nothing) = false  # Linear Solve automatically will use a correct alg!$/;"	f
needs_square_A	src/LinearSolve.jl	/^needs_square_A(alg::SciMLLinearSolveAlgorithm) = true$/;"	f
nnz	src/KLU/klu.jl	/^nnz(K::AbstractKLUFactorization) = K.lnz + K.unz + K.nzoff$/;"	f
noffdiag	src/KLU/wrappers.jl	/^    noffdiag::Int32$/;"	g	struct:klu_common_struct
noffdiag	src/KLU/wrappers.jl	/^    noffdiag::Int64$/;"	g	struct:klu_l_common_struct
nonzeros	src/LinearSolve.jl	/^nonzeros(A) = error("SparseArrays extension not loaded")$/;"	f	module:LinearSolve
nonzeros	test/basictests.jl	/^    SparseArrays.nonzeros(m::MySparseMatrixCSC) = SparseArrays.nonzeros(m.csc)$/;"	f	module:SparseArrays
nonzeros	test/pardiso/pardiso.jl	/^    SparseArrays.nonzeros(m::MySparseMatrixCSC2) = SparseArrays.nonzeros(m.csc)$/;"	f	module:SparseArrays
nprocs	src/extension_algs.jl	/^    nprocs::Union{Int, Nothing}$/;"	g	struct:PardisoJL
nrealloc	src/KLU/wrappers.jl	/^    nrealloc::Cint$/;"	g	struct:klu_common_struct
nrealloc	src/KLU/wrappers.jl	/^    nrealloc::Cint$/;"	g	struct:klu_l_common_struct
numerical_rank	src/KLU/wrappers.jl	/^    numerical_rank::Int32$/;"	g	struct:klu_common_struct
numerical_rank	src/KLU/wrappers.jl	/^    numerical_rank::Int64$/;"	g	struct:klu_l_common_struct
nz	src/KLU/wrappers.jl	/^    nz::Int32$/;"	g	struct:klu_symbolic
nz	src/KLU/wrappers.jl	/^    nz::Int64$/;"	g	struct:klu_l_symbolic
nzoff	src/KLU/wrappers.jl	/^    nzoff::Int32$/;"	g	struct:klu_numeric
nzoff	src/KLU/wrappers.jl	/^    nzoff::Int32$/;"	g	struct:klu_symbolic
nzoff	src/KLU/wrappers.jl	/^    nzoff::Int64$/;"	g	struct:klu_l_numeric
nzoff	src/KLU/wrappers.jl	/^    nzoff::Int64$/;"	g	struct:klu_l_symbolic
nzval	src/KLU/klu.jl	/^    nzval::Vector{Tv}$/;"	g	struct:KLU.KLUFactorization
ordering	src/KLU/wrappers.jl	/^    ordering::Cint$/;"	g	struct:klu_common_struct
ordering	src/KLU/wrappers.jl	/^    ordering::Cint$/;"	g	struct:klu_l_common_struct
ordering	src/KLU/wrappers.jl	/^    ordering::Int32$/;"	g	struct:klu_symbolic
ordering	src/KLU/wrappers.jl	/^    ordering::Int64$/;"	g	struct:klu_l_symbolic
outer	src/preconditioners.jl	/^    outer::To$/;"	g	struct:ComposePreconditioner
p	src/common.jl	/^    p::Tp$/;"	g	struct:LinearCache
p	src/simplegmres.jl	/^    x$/;"	g	struct:SimpleGMRESCache
parameterless_type	benchmarks/applelu.jl	/^parameterless_type(::Type{T}) where {T} = __parameterless_type(T)$/;"	f
parameterless_type	benchmarks/applelu.jl	/^parameterless_type(x) = __parameterless_type(typeof(x))$/;"	f
parameterless_type	benchmarks/cudalu.jl	/^parameterless_type(::Type{T}) where {T} = __parameterless_type(T)$/;"	f
parameterless_type	benchmarks/cudalu.jl	/^parameterless_type(x) = __parameterless_type(typeof(x))$/;"	f
parameterless_type	benchmarks/lu.jl	/^parameterless_type(::Type{T}) where {T} = __parameterless_type(T)$/;"	f
parameterless_type	benchmarks/lu.jl	/^parameterless_type(x) = __parameterless_type(typeof(x))$/;"	f
parameterless_type	benchmarks/metallu.jl	/^parameterless_type(::Type{T}) where {T} = __parameterless_type(T)$/;"	f
parameterless_type	benchmarks/metallu.jl	/^parameterless_type(x) = __parameterless_type(typeof(x))$/;"	f
parameterless_type	benchmarks/sparselu.jl	/^parameterless_type(::Type{T}) where {T} = __parameterless_type(T)$/;"	f
parameterless_type	benchmarks/sparselu.jl	/^parameterless_type(x) = __parameterless_type(typeof(x))$/;"	f
pattern_changed	ext/LinearSolveSparseArraysExt.jl	/^function LinearSolve.pattern_changed(fact, A::SparseArrays.SparseMatrixCSC)$/;"	f	module:LinearSolve
pattern_changed	src/LinearSolve.jl	/^pattern_changed(fact, A) = false$/;"	f	module:LinearSolve
perm	src/factorization.jl	/^    perm::P2$/;"	g	struct:CholeskyFactorization
perm	src/factorization.jl	/^    perm::T = nothing$/;"	g	struct:CHOLMODFactorization
perm	src/factorization.jl	/^    perm::T$/;"	g	struct:LDLtFactorization
perms	src/simplelu.jl	/^    perms::Vector{Int}$/;"	g	struct:LUSolver
pivot	src/extension_algs.jl	/^    pivot::P$/;"	g	struct:FastQRFactorization
pivot	src/factorization.jl	/^    pivot::P = LinearAlgebra.RowMaximum()$/;"	g	struct:LUFactorization
pivot	src/factorization.jl	/^    pivot::P$/;"	g	struct:CholeskyFactorization
pivot	src/factorization.jl	/^    pivot::P$/;"	g	struct:GenericLUFactorization
pivot	src/factorization.jl	/^    pivot::P$/;"	g	struct:NormalCholeskyFactorization
pivot	src/factorization.jl	/^    pivot::P$/;"	g	struct:QRFactorization
pivot	src/simplelu.jl	/^    pivot::Bool$/;"	g	struct:SimpleLUFactorization
pivots	src/simplelu.jl	/^    pivots::Vector{Int}$/;"	g	struct:LUSolver
precs	src/extension_algs.jl	/^    precs::P$/;"	g	struct:IterativeSolversJL
precs	src/extension_algs.jl	/^    precs::P$/;"	g	struct:KrylovKitJL
precs	src/iterative_wrappers.jl	/^    precs::P$/;"	g	struct:KrylovJL
precsisfresh	src/common.jl	/^    precsisfresh::Bool # false => PR,PL is set wrt A, true => update PR,PL wrt A$/;"	g	struct:LinearCache
propertynames	src/KLU/klu.jl	/^function Base.propertynames(::AbstractKLUFactorization, private::Bool = false)$/;"	f	module:Base
purge_history!	ext/LinearSolveIterativeSolversExt.jl	/^function purge_history!(iter::IterativeSolvers.GMRESIterable, x, b)$/;"	f	module:LinearSolveIterativeSolversExt
purge_history!	ext/LinearSolveIterativeSolversExt.jl	/^purge_history!(iter, x, b) = nothing$/;"	f	module:LinearSolveIterativeSolversExt
q	src/simplegmres.jl	/^    p$/;"	g	struct:SimpleGMRESCache
rank	test/hypretests_mpi.jl	/^const rank = MPI.Comm_rank(comm)$/;"	c
rcond	src/KLU/klu.jl	/^        function rcond(K::AbstractKLUFactorization{$Tv, $Ti})$/;"	f
rcond	src/KLU/wrappers.jl	/^    rcond::Cdouble$/;"	g	struct:klu_common_struct
rcond	src/KLU/wrappers.jl	/^    rcond::Cdouble$/;"	g	struct:klu_l_common_struct
reinit!	src/common.jl	/^function SciMLBase.reinit!(cache::LinearCache;$/;"	f	module:SciMLBase
reltol	src/common.jl	/^    reltol::Ttol$/;"	g	struct:LinearCache
reltol	src/simplegmres.jl	/^    w$/;"	g	struct:SimpleGMRESCache
restart	src/simplegmres.jl	/^    restart::Bool$/;"	g	struct:SimpleGMRES
restart	src/simplegmres.jl	/^    restart::Bool$/;"	g	struct:SimpleGMRESCache
reuse_symbolic	src/factorization.jl	/^    reuse_symbolic::Bool = true$/;"	g	struct:KLUFactorization
reuse_symbolic	src/factorization.jl	/^    reuse_symbolic::Bool = true$/;"	g	struct:LUFactorization
reuse_symbolic	src/factorization.jl	/^    reuse_symbolic::Bool = true$/;"	g	struct:UMFPACKFactorization
reuse_symbolic	src/factorization.jl	/^    reuse_symbolic::Bool$/;"	g	struct:SparspakFactorization
reverse	ext/LinearSolveEnzymeExt.jl	/^function EnzymeRules.reverse($/;"	f	module:EnzymeRules
reverse	ext/LinearSolveEnzymeExt.jl	/^function EnzymeRules.reverse(config, func::Const{typeof(LinearSolve.solve!)},$/;"	f	module:EnzymeRules
rgrowth	src/KLU/klu.jl	/^        function rgrowth(K::KLUFactorization{$Tv, $Ti})$/;"	f
rgrowth	src/KLU/wrappers.jl	/^    rgrowth::Cdouble$/;"	g	struct:klu_common_struct
rgrowth	src/KLU/wrappers.jl	/^    rgrowth::Cdouble$/;"	g	struct:klu_l_common_struct
rook	src/factorization.jl	/^    rook::Bool = false$/;"	g	struct:BunchKaufmanFactorization
rook	src/factorization.jl	/^    rook::Bool$/;"	g	struct:NormalBunchKaufmanFactorization
rowval	src/KLU/klu.jl	/^    rowval::Vector{Ti}$/;"	g	struct:KLU.KLUFactorization
rowvals	src/LinearSolve.jl	/^rowvals(A) = error("SparseArrays extension not loaded")$/;"	f	module:LinearSolve
rowvals	test/basictests.jl	/^    SparseArrays.rowvals(m::MySparseMatrixCSC) = SparseArrays.rowvals(m.csc)$/;"	f	module:SparseArrays
rowvals	test/pardiso/pardiso.jl	/^    SparseArrays.rowvals(m::MySparseMatrixCSC2) = SparseArrays.rowvals(m.csc)$/;"	f	module:SparseArrays
rrule	src/adjoint.jl	/^function CRC.rrule(::Type{<:LinearProblem}, A, b, p; kwargs...)$/;"	f	module:CRC
rrule	src/adjoint.jl	/^function CRC.rrule(::typeof(SciMLBase.solve), prob::LinearProblem,$/;"	f	module:CRC
rrule	src/adjoint.jl	/^function CRC.rrule(T::typeof(SciMLBase.solve), prob::LinearProblem, alg::Nothing, args...; kwarg/;"	f	module:CRC
run_and_plot	benchmarks/sparselu.jl	/^function run_and_plot(; dims = [1, 2, 3], kmax = 12)$/;"	f
s	src/simplegmres.jl	/^    c$/;"	g	struct:SimpleGMRESCache
safetyfallback	src/LinearSolve.jl	/^    safetyfallback::Bool$/;"	g	struct:LinearSolve.DefaultLinearSolver
scale	src/KLU/wrappers.jl	/^    scale::Cint$/;"	g	struct:klu_common_struct
scale	src/KLU/wrappers.jl	/^    scale::Cint$/;"	g	struct:klu_l_common_struct
sciml-bridged	README.md	/^[![Join the chat at https:\/\/julialang.zulipchat.com #sciml-bridged](https:\/\/img.shields.io\//;"	h	chapter:LinearSolve.jl
sensealg	src/common.jl	/^    sensealg::S$/;"	g	struct:LinearCache
setproperty!	ext/LinearSolveHYPREExt.jl	/^function Base.setproperty!(cache::LinearCacheHYPRE, name::Symbol, x)$/;"	f	module:Base
setproperty!	src/KLU/klu.jl	/^function setproperty!(klu::AbstractKLUFactorization, ::Val{:(_numeric)}, x)$/;"	f
setproperty!	src/KLU/klu.jl	/^function setproperty!(klu::AbstractKLUFactorization, ::Val{:(_symbolic)}, x)$/;"	f
setproperty!	src/common.jl	/^function Base.setproperty!(cache::LinearCache, name::Symbol, x)$/;"	f	module:Base
shift	src/factorization.jl	/^    shift::Float64 = 0.0$/;"	g	struct:CHOLMODFactorization
shift	src/factorization.jl	/^    shift::Float64$/;"	g	struct:CholeskyFactorization
shift	src/factorization.jl	/^    shift::Float64$/;"	g	struct:LDLtFactorization
show	src/KLU/klu.jl	/^function show(io::IO, mime::MIME{Symbol("text\/plain")}, K::AbstractKLUFactorization)$/;"	f
simplelu_factorize!	src/simplelu.jl	/^function simplelu_factorize!(lu::LUSolver{T}, pivot = true) where {T}$/;"	f
simplelu_solve!	src/simplelu.jl	/^function simplelu_solve!(lu::LUSolver{T}) where {T}$/;"	f
singular_col	src/KLU/wrappers.jl	/^    singular_col::Int32$/;"	g	struct:klu_common_struct
singular_col	src/KLU/wrappers.jl	/^    singular_col::Int64$/;"	g	struct:klu_l_common_struct
size	src/KLU/klu.jl	/^function size(K::AbstractKLUFactorization, dim::Integer)$/;"	f
size	src/KLU/klu.jl	/^size(K::AbstractKLUFactorization) = (K.n, K.n)$/;"	f
size	test/basictests.jl	/^    Base.size(m::MySparseMatrixCSC) = size(m.csc)$/;"	f	module:Base
size	test/pardiso/pardiso.jl	/^    Base.size(m::MySparseMatrixCSC2) = size(m.csc)$/;"	f	module:Base
slash_f	test/forwarddiff_overloads.jl	/^function slash_f(p)$/;"	f
slash_f_hes	test/forwarddiff_overloads.jl	/^function slash_f_hes(p)$/;"	f
sol_func	test/basictests.jl	/^            function sol_func(A, b, u, p, newA, Pl, Pr, solverdata; verbose = true,$/;"	f
sol_func!	test/basictests.jl	/^            function sol_func!(A, b, u, p, newA, Pl, Pr, solverdata; verbose = true,$/;"	f
solve	src/KLU/klu.jl	/^function solve(klu, B; check = true)$/;"	f
solve	src/common.jl	/^function SciMLBase.solve(prob::LinearProblem, ::Nothing, args...;$/;"	f	module:SciMLBase
solve	src/common.jl	/^function SciMLBase.solve(prob::LinearProblem, alg::SciMLLinearSolveAlgorithm,$/;"	f	module:SciMLBase
solve	src/common.jl	/^function SciMLBase.solve(prob::LinearProblem, args...; kwargs...)$/;"	f	module:SciMLBase
solve	src/common.jl	/^function SciMLBase.solve(prob::StaticLinearProblem, args...; kwargs...)$/;"	f	module:SciMLBase
solve	src/common.jl	/^function SciMLBase.solve(prob::StaticLinearProblem,$/;"	f	module:SciMLBase
solve!	ext/LinearSolveCUDAExt.jl	/^function SciMLBase.solve!(cache::LinearSolve.LinearCache, alg::CudaOffloadFactorization;$/;"	f	module:SciMLBase
solve!	ext/LinearSolveFastLapackInterfaceExt.jl	/^function SciMLBase.solve!($/;"	f	module:SciMLBase
solve!	ext/LinearSolveFastLapackInterfaceExt.jl	/^function SciMLBase.solve!(cache::LinearSolve.LinearCache, alg::FastQRFactorization{P};$/;"	f	module:SciMLBase
solve!	ext/LinearSolveHYPREExt.jl	/^function SciMLBase.solve!(cache::LinearCache, alg::HYPREAlgorithm, args...; kwargs...)$/;"	f	module:SciMLBase
solve!	ext/LinearSolveIterativeSolversExt.jl	/^function SciMLBase.solve!(cache::LinearCache, alg::IterativeSolversJL; kwargs...)$/;"	f	module:SciMLBase
solve!	ext/LinearSolveKrylovKitExt.jl	/^function SciMLBase.solve!(cache::LinearCache, alg::KrylovKitJL; kwargs...)$/;"	f	module:SciMLBase
solve!	ext/LinearSolveMetalExt.jl	/^function SciMLBase.solve!(cache::LinearCache, alg::MetalLUFactorization;$/;"	f	module:SciMLBase
solve!	ext/LinearSolvePardisoExt.jl	/^function SciMLBase.solve!(cache::LinearSolve.LinearCache, alg::PardisoJL; kwargs...)$/;"	f	module:SciMLBase
solve!	ext/LinearSolveRecursiveFactorizationExt.jl	/^function SciMLBase.solve!(cache::LinearSolve.LinearCache, alg::RFLUFactorization{P, T};$/;"	f	module:SciMLBase
solve!	ext/LinearSolveSparseArraysExt.jl	/^function SciMLBase.solve!($/;"	f	module:SciMLBase
solve!	ext/LinearSolveSparseArraysExt.jl	/^function SciMLBase.solve!(cache::LinearSolve.LinearCache, alg::KLUFactorization; kwargs...)$/;"	f	module:SciMLBase
solve!	ext/LinearSolveSparspakExt.jl	/^function SciMLBase.solve!($/;"	f	module:SciMLBase
solve!	src/KLU/klu.jl	/^        function solve!(klu::AbstractKLUFactorization{$Tv, $Ti},$/;"	f
solve!	src/KLU/klu.jl	/^        function solve!(klu::AdjointFact{$Tv, K}, B::StridedVecOrMat{$Tv};$/;"	f
solve!	src/KLU/klu.jl	/^        function solve!(klu::TransposeFact{$Tv, K}, B::StridedVecOrMat{$Tv};$/;"	f
solve!	src/appleaccelerate.jl	/^function SciMLBase.solve!(cache::LinearCache, alg::AppleAccelerateLUFactorization;$/;"	f	module:SciMLBase
solve!	src/common.jl	/^function SciMLBase.solve!(cache::LinearCache, args...; kwargs...)$/;"	f	module:SciMLBase
solve!	src/default.jl	/^@generated function SciMLBase.solve!(cache::LinearCache, alg::DefaultLinearSolver,$/;"	f	module:SciMLBase
solve!	src/default.jl	/^function SciMLBase.solve!(cache::LinearCache, alg::Nothing,$/;"	f	module:SciMLBase
solve!	src/factorization.jl	/^@generated function SciMLBase.solve!(cache::LinearCache, alg::AbstractFactorization;$/;"	f	module:SciMLBase
solve!	src/factorization.jl	/^function SciMLBase.solve!(cache::LinearCache, alg::CHOLMODFactorization; kwargs...)$/;"	f	module:SciMLBase
solve!	src/factorization.jl	/^function SciMLBase.solve!(cache::LinearCache, alg::DiagonalFactorization;$/;"	f	module:SciMLBase
solve!	src/factorization.jl	/^function SciMLBase.solve!(cache::LinearCache, alg::LUFactorization; kwargs...)$/;"	f	module:SciMLBase
solve!	src/factorization.jl	/^function SciMLBase.solve!(cache::LinearCache, alg::NormalBunchKaufmanFactorization;$/;"	f	module:SciMLBase
solve!	src/factorization.jl	/^function SciMLBase.solve!(cache::LinearCache, alg::NormalCholeskyFactorization; kwargs...)$/;"	f	module:SciMLBase
solve!	src/factorization.jl	/^function SciMLBase.solve!(cache::LinearSolve.LinearCache, alg::GenericLUFactorization;$/;"	f	module:SciMLBase
solve!	src/iterative_wrappers.jl	/^function SciMLBase.solve!(cache::LinearCache, alg::KrylovJL; kwargs...)$/;"	f	module:SciMLBase
solve!	src/mkl.jl	/^function SciMLBase.solve!(cache::LinearCache, alg::MKLLUFactorization;$/;"	f	module:SciMLBase
solve!	src/simplegmres.jl	/^function SciMLBase.solve!(cache::LinearCache, alg::SimpleGMRES; kwargs...)$/;"	f	module:SciMLBase
solve!	src/simplegmres.jl	/^function SciMLBase.solve!(cache::SimpleGMRESCache{false}, lincache::LinearCache)$/;"	f	module:SciMLBase
solve!	src/simplegmres.jl	/^function SciMLBase.solve!(cache::SimpleGMRESCache{true}, lincache::LinearCache)$/;"	f	module:SciMLBase
solve!	src/simplelu.jl	/^function SciMLBase.solve!(cache::LinearCache, alg::SimpleLUFactorization; kwargs...)$/;"	f	module:SciMLBase
solve!	src/solve_function.jl	/^function SciMLBase.solve!(cache::LinearCache, alg::DirectLdiv!, args...; kwargs...)$/;"	f	module:SciMLBase
solve!	src/solve_function.jl	/^function SciMLBase.solve!(cache::LinearCache, alg::LinearSolveFunction,$/;"	f	module:SciMLBase
solve_func	src/solve_function.jl	/^    solve_func::F$/;"	g	struct:LinearSolveFunction
solver	ext/LinearSolveHYPREExt.jl	/^    solver::Union{HYPRE.HYPRESolver, Nothing}$/;"	g	struct:LinearSolveHYPREExt.HYPRECache
solver	src/extension_algs.jl	/^    solver::Any$/;"	g	struct:HYPREAlgorithm
solver_type	src/extension_algs.jl	/^    solver_type::T1$/;"	g	struct:PardisoJL
status	src/KLU/wrappers.jl	/^    status::Cint$/;"	g	struct:klu_common_struct
status	src/KLU/wrappers.jl	/^    status::Cint$/;"	g	struct:klu_l_common_struct
structural_rank	src/KLU/wrappers.jl	/^    structural_rank::Int32$/;"	g	struct:klu_common_struct
structural_rank	src/KLU/wrappers.jl	/^    structural_rank::Int32$/;"	g	struct:klu_symbolic
structural_rank	src/KLU/wrappers.jl	/^    structural_rank::Int64$/;"	g	struct:klu_l_common_struct
structural_rank	src/KLU/wrappers.jl	/^    structural_rank::Int64$/;"	g	struct:klu_l_symbolic
symamd	src/KLU/wrappers.jl	/^function symamd(n, A, p, perm, knobs, stats, allocate, release)$/;"	f
symamd_l	src/KLU/wrappers.jl	/^function symamd_l(n, A, p, perm, knobs, stats, allocate, release)$/;"	f
symamd_l_report	src/KLU/wrappers.jl	/^function symamd_l_report(stats)$/;"	f
symamd_report	src/KLU/wrappers.jl	/^function symamd_report(stats)$/;"	f
symmetry	src/KLU/wrappers.jl	/^    symmetry::Cdouble$/;"	g	struct:klu_l_symbolic
symmetry	src/KLU/wrappers.jl	/^    symmetry::Cdouble$/;"	g	struct:klu_symbolic
test_interface	test/basictests.jl	/^function test_interface(alg, prob1, prob2)$/;"	f
test_interface	test/gpu/cuda.jl	/^function test_interface(alg, prob1, prob2)$/;"	f
test_interface	test/hypretests.jl	/^function test_interface(alg; kw...)$/;"	f
test_nonzero_init	test/zeroinittests.jl	/^function test_nonzero_init(alg = nothing)$/;"	f
testls	test/nopre/enzyme.jl	/^function testls(A, b, u)$/;"	f
to_array	test/hypretests.jl	/^function to_array(A::HYPREMatrix)$/;"	f
to_array	test/hypretests.jl	/^function to_array(b::HYPREVector)$/;"	f
to_array	test/hypretests.jl	/^to_array(x) = x$/;"	f
tol	src/KLU/wrappers.jl	/^    tol::Cdouble$/;"	g	struct:klu_common_struct
tol	src/KLU/wrappers.jl	/^    tol::Cdouble$/;"	g	struct:klu_l_common_struct
tol	src/factorization.jl	/^    tol::Int$/;"	g	struct:CholeskyFactorization
transpose	src/KLU/klu.jl	/^Base.transpose(K::AbstractKLUFactorization) = TransposeFact(K)$/;"	f	module:Base
u	ext/LinearSolveHYPREExt.jl	/^    u::Union{HYPREVector, Nothing}$/;"	g	struct:LinearSolveHYPREExt.HYPRECache
u	src/common.jl	/^    u::Tu$/;"	g	struct:LinearCache
unz	src/KLU/wrappers.jl	/^    unz::Cdouble$/;"	g	struct:klu_l_symbolic
unz	src/KLU/wrappers.jl	/^    unz::Cdouble$/;"	g	struct:klu_symbolic
unz	src/KLU/wrappers.jl	/^    unz::Int32$/;"	g	struct:klu_numeric
unz	src/KLU/wrappers.jl	/^    unz::Int64$/;"	g	struct:klu_l_numeric
update_cacheval!	src/common.jl	/^function update_cacheval!(cache::LinearCache, name::Symbol, x)$/;"	f
update_cacheval!	src/common.jl	/^update_cacheval!(cache, cacheval, name::Symbol, x) = cacheval$/;"	f
update_cacheval!	src/simplegmres.jl	/^function update_cacheval!(cache::LinearCache, cacheval::SimpleGMRESCache, name::Symbol, x)$/;"	f
usemkl	src/LinearSolve.jl	/^        const usemkl = MKL_jll.is_available()$/;"	c	module:LinearSolve
usemkl	src/LinearSolve.jl	/^        const usemkl = false$/;"	c	module:LinearSolve
usemkl	src/LinearSolve.jl	/^    const usemkl = false$/;"	c	module:LinearSolve
user_data	src/KLU/wrappers.jl	/^    user_data::Ptr{Cvoid}$/;"	g	struct:klu_common_struct
user_data	src/KLU/wrappers.jl	/^    user_data::Ptr{Cvoid}$/;"	g	struct:klu_l_common_struct
user_order	src/KLU/wrappers.jl	/^    user_order::Ptr{Cvoid}$/;"	g	struct:klu_common_struct
user_order	src/KLU/wrappers.jl	/^    user_order::Ptr{Cvoid}$/;"	g	struct:klu_l_common_struct
userecursivefactorization	ext/LinearSolveRecursiveFactorizationExt.jl	/^LinearSolve.userecursivefactorization(A::Union{Nothing, AbstractMatrix}) = true$/;"	f	module:LinearSolve
userecursivefactorization	src/default.jl	/^userecursivefactorization(A) = false$/;"	f
v2.0	docs/src/release_notes.md	/^## v2.0$/;"	s	chapter:Release Notes
vendor	src/extension_algs.jl	/^    vendor::Union{Symbol, Nothing}$/;"	g	struct:PardisoJL
verbose	src/common.jl	/^    verbose::Bool$/;"	g	struct:LinearCache
w	src/simplegmres.jl	/^    V$/;"	g	struct:SimpleGMRESCache
warm_start	src/simplegmres.jl	/^    warm_start::Bool$/;"	g	struct:SimpleGMRES
warm_start	src/simplegmres.jl	/^    warm_start::Bool$/;"	g	struct:SimpleGMRESCache
window	src/iterative_wrappers.jl	/^    window::I$/;"	g	struct:KrylovJL
work	src/KLU/wrappers.jl	/^    work::Cdouble$/;"	g	struct:klu_common_struct
work	src/KLU/wrappers.jl	/^    work::Cdouble$/;"	g	struct:klu_l_common_struct
worksize	src/KLU/wrappers.jl	/^    worksize::Csize_t$/;"	g	struct:klu_l_numeric
worksize	src/KLU/wrappers.jl	/^    worksize::Csize_t$/;"	g	struct:klu_numeric
workspace	ext/LinearSolveFastLapackInterfaceExt.jl	/^    workspace::W$/;"	g	struct:LinearSolveFastLapackInterfaceExt.WorkspaceAndFactors
x	src/simplegmres.jl	/^    A$/;"	g	struct:SimpleGMRESCache
x	src/simplelu.jl	/^    x::Vector{T}$/;"	g	struct:LUSolver
z	src/simplegmres.jl	/^    R$/;"	g	struct:SimpleGMRESCache
Δx	src/simplegmres.jl	/^    q$/;"	g	struct:SimpleGMRESCache
β	src/simplegmres.jl	/^    warm_start::Bool$/;"	g	struct:SimpleGMRESCache
ε	src/simplegmres.jl	/^    PlisI::Bool$/;"	g	struct:SimpleGMRESCache
∇linear_solve	src/adjoint.jl	/^    function ∇linear_solve(∂sol)$/;"	f	function:rrule
∇prob	src/adjoint.jl	/^    ∇prob(∂prob) = (NoTangent(), ∂prob.A, ∂prob.b, ∂prob.p)$/;"	f	function:rrule
