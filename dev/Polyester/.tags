!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!Julia	Y,unknown	/name defined in other modules/
!_TAG_KIND_DESCRIPTION!Julia	c,constant	/Constants/
!_TAG_KIND_DESCRIPTION!Julia	f,function	/Functions/
!_TAG_KIND_DESCRIPTION!Julia	g,field	/Fields/
!_TAG_KIND_DESCRIPTION!Julia	m,macro	/Macros/
!_TAG_KIND_DESCRIPTION!Julia	n,module	/Modules/
!_TAG_KIND_DESCRIPTION!Julia	s,struct	/Structures/
!_TAG_KIND_DESCRIPTION!Julia	t,type	/Types/
!_TAG_KIND_DESCRIPTION!Markdown	S,subsection	/level 2 sections/
!_TAG_KIND_DESCRIPTION!Markdown	T,l4subsection	/level 4 sections/
!_TAG_KIND_DESCRIPTION!Markdown	c,chapter	/chapters/
!_TAG_KIND_DESCRIPTION!Markdown	h,hashtag	/hashtags/
!_TAG_KIND_DESCRIPTION!Markdown	n,footnote	/footnotes/
!_TAG_KIND_DESCRIPTION!Markdown	s,section	/sections/
!_TAG_KIND_DESCRIPTION!Markdown	t,subsubsection	/level 3 sections/
!_TAG_KIND_DESCRIPTION!Markdown	u,l5subsection	/level 5 sections/
!_TAG_KIND_DESCRIPTION!Yaml	a,anchor	/anchors/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	1.1	/current.age/
!_TAG_PARSER_VERSION!Julia	0.0	/current.age/
!_TAG_PARSER_VERSION!Markdown	1.1	/current.age/
!_TAG_PARSER_VERSION!Yaml	0.0	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/romeo/.julia/dev/Polyester/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.2.0	/v6.2.0/
!_TAG_ROLE_DESCRIPTION!Julia!module	imported	/loaded by "import"/
!_TAG_ROLE_DESCRIPTION!Julia!module	namespace	/only some symbols in it are imported/
!_TAG_ROLE_DESCRIPTION!Julia!module	used	/loaded by "using"/
!_TAG_ROLE_DESCRIPTION!Julia!unknown	imported	/loaded by "import"/
!_TAG_ROLE_DESCRIPTION!Julia!unknown	used	/loaded by "using"/
!_TAG_ROLE_DESCRIPTION!Yaml!anchor	alias	/alias/
ArrayInterface	src/Polyester.jl	/^const ArrayInterface = StaticArrayInterface$/;"	c	module:Polyester
Basic usage example	README.md	/^## Basic usage example$/;"	s	chapter:Polyester
BatchClosure	src/batch.jl	/^struct BatchClosure{F,A,S,C}$/;"	s
CombineIndices	src/closure.jl	/^struct CombineIndices end$/;"	s
Disabling Polyester threads	README.md	/^## Disabling Polyester threads$/;"	s	chapter:Polyester
Important Notes	README.md	/^## Important Notes$/;"	s	chapter:Polyester
Issue20	test/runtests.jl	/^  struct Issue20$/;"	s
Keyword options for `@batch`	README.md	/^## Keyword options for `@batch`$/;"	s	chapter:Polyester
LazyTree	test/runtests.jl	/^struct LazyTree{T}$/;"	s
Local per-thread storage (`threadlocal`)	README.md	/^### Local per-thread storage (`threadlocal`)$/;"	S	section:Polyester""Keyword options for `@batch`
NoLoop	src/closure.jl	/^struct NoLoop end$/;"	s	function:define_induction_variables!
Polyester	README.md	/^# Polyester$/;"	c
Polyester	docs/src/index.md	/^# Polyester$/;"	c
Polyester	src/Polyester.jl	/^module Polyester$/;"	n
SUPPORTED_REDUCE_OPS	src/Polyester.jl	/^const SUPPORTED_REDUCE_OPS = (:+, :*, :min, :max, :&, :|)$/;"	c	module:Polyester
Simple benchmark	README.md	/^## Simple benchmark$/;"	s	chapter:Polyester
TestStruct	test/runtests.jl	/^  mutable struct TestStruct$/;"	s
TupleIndices	src/closure.jl	/^struct TupleIndices end$/;"	s
WrapType	src/closure.jl	/^struct WrapType{T} end$/;"	s
_batch_no_reserve	src/batch.jl	/^@generated function _batch_no_reserve($/;"	f
_extract_params	src/batch.jl	/^_extract_params(::Type{NamedTuple{S,T}}) where {S,T<:Tuple} = T.parameters$/;"	f
_extract_params	src/batch.jl	/^_extract_params(::Type{T}) where {T<:Tuple} = T.parameters$/;"	f
_symbols	src/closure.jl	/^function _symbols(args)$/;"	f
`minbatch`	README.md	/^### `minbatch`$/;"	S	section:Polyester""Keyword options for `@batch`
`per=cores` / `per=threads`	README.md	/^### `per=cores` \/ `per=threads`$/;"	S	section:Polyester""Keyword options for `@batch`
`reduction`	README.md	/^### `reduction`$/;"	S	section:Polyester""Keyword options for `@batch`
add_var!	src/batch.jl	/^function add_var!(q, argtup, gcpres, ::Type{T}, argtupname, gcpresname, k) where {T}$/;"	f
allocated	test/runtests.jl	/^  allocated(f::F) where {F} = @allocated f()$/;"	f
allocated	test/runtests.jl	/^  allocated(f::F, args...) where {F} = @allocated f(args...)$/;"	f
bar!	test/runtests.jl	/^function bar!(dest, src)$/;"	f
batch	src/batch.jl	/^@inline function batch($/;"	f
batch	src/batch.jl	/^function batch($/;"	f
batch	src/closure.jl	/^macro batch(arg1, arg2, arg3, arg4, arg5, ex)$/;"	m
batch	src/closure.jl	/^macro batch(arg1, arg2, arg3, arg4, ex)$/;"	m
batch	src/closure.jl	/^macro batch(arg1, arg2, arg3, ex)$/;"	m
batch	src/closure.jl	/^macro batch(arg1, arg2, ex)$/;"	m
batch	src/closure.jl	/^macro batch(arg1, ex)$/;"	m
batch	src/closure.jl	/^macro batch(ex)$/;"	m
batch_closure	src/batch.jl	/^@generated function batch_closure(f::F, args::A, ::Val{S}, reducinits::C) where {F,A,S,C}$/;"	f
bcos!	test/runtests.jl	/^function bcos!(y, x)$/;"	f
bsin!	test/runtests.jl	/^function bsin!(y, x, r = eachindex(y, x))$/;"	f
bsin_stride!	test/runtests.jl	/^function bsin_stride!(y, x, r = eachindex(y, x))$/;"	f
combine	src/closure.jl	/^Base.@propagate_inbounds combine(x::AbstractArray, ::NoLoop, j) = x[j]$/;"	f
combine	src/closure.jl	/^Base.@propagate_inbounds combine(x::AbstractArray, I, j) =$/;"	f
combine	src/closure.jl	/^combine(::CombineIndices, ::NoLoop, x) = x$/;"	f
combine	src/closure.jl	/^combine(::CombineIndices, I::CartesianIndex, j) = CartesianIndex((I.I..., j))$/;"	f
combine	src/closure.jl	/^combine(::TupleIndices, i::Number, j) = (i, j)$/;"	f
combine	src/closure.jl	/^combine(::TupleIndices, i::Tuple, j) = (i..., j)$/;"	f
combine	test/runtests.jl	/^combine(e::Iterators.Enumerate{LazyTree{T}}, ::NoLoop, j) where {T} = @inbounds e[j]$/;"	f
define1!	src/closure.jl	/^function define1!($/;"	f
define_induction_variables!	src/closure.jl	/^function define_induction_variables!($/;"	f
define_tup!	src/closure.jl	/^function define_tup!(arguments::Vector{Symbol}, defined::Dict{Symbol,Symbol}, ex::Expr, mod)$/;"	f
dummy_broadcast!	test/runtests.jl	/^function dummy_broadcast!(x)$/;"	f
eachindex	test/runtests.jl	/^Base.eachindex(e::Iterators.Enumerate{LazyTree{T}}) where {T} = eachindex(e.itr)$/;"	f	module:Base
eachindex	test/runtests.jl	/^Base.eachindex(lt::LazyTree) = 1:lastindex(lt)$/;"	f	module:Base
enclose	src/closure.jl	/^function enclose(exorig::Expr, minbatchsize, per, threadlocal, reduction, stride, mod)$/;"	f
extractargs!	src/closure.jl	/^extractargs!(arguments::Vector{Symbol}, defined::Dict{Symbol,Symbol}, sym, mod) = nothing$/;"	f
extractargs!	src/closure.jl	/^function extractargs!($/;"	f	function:define_induction_variables!
extractargs_equal!	src/closure.jl	/^function extractargs_equal!($/;"	f	function:define_induction_variables!
f	src/batch.jl	/^  f::F$/;"	g	struct:BatchClosure
f	test/runtests.jl	/^  f(a; b = 10.0, c = 100.0) = a + b + c$/;"	f
f	test/runtests.jl	/^  function f()$/;"	f
f	test/runtests.jl	/^  function f(; kw = 10)$/;"	f
ff	test/runtests.jl	/^  function ff(buf, a)$/;"	f
find_call_to_nthreads	test/runtests.jl	/^  function find_call_to_nthreads(expr)$/;"	f
firstindex	test/runtests.jl	/^Base.firstindex(e::Iterators.Enumerate{LazyTree{T}}) where {T} = firstindex(e.itr)$/;"	f	module:Base
foo	test/runtests.jl	/^  foo(x, y) = exp(-0.5abs2(x - y))$/;"	f
get_sym!	src/closure.jl	/^function get_sym!(defined::Dict{Symbol,Symbol}, arguments::Vector{Symbol}, arg::Symbol, mod)$/;"	f	function:define_induction_variables!
getgensym!	src/closure.jl	/^function getgensym!(defined::Dict{Symbol,Symbol}, s::Symbol)$/;"	f
getindex	test/runtests.jl	/^Base.getindex(e::Iterators.Enumerate{LazyTree{T}}, row::Int) where {T} =$/;"	f	module:Base
getindex	test/runtests.jl	/^Base.getindex(lt::LazyTree, row::Int) = lt.t[row]$/;"	f	module:Base
inferred	test/runtests.jl	/^  inferred(f::F) where {F} =$/;"	f
initializer	src/Polyester.jl	/^initializer(::typeof(&), ::Bool) = true$/;"	f	module:Polyester
initializer	src/Polyester.jl	/^initializer(::typeof(*), ::T) where {T} = one(T)$/;"	f	module:Polyester
initializer	src/Polyester.jl	/^initializer(::typeof(+), ::Bool) = zero(Int)$/;"	f	module:Polyester
initializer	src/Polyester.jl	/^initializer(::typeof(+), ::T) where {T} = zero(T)$/;"	f	module:Polyester
initializer	src/Polyester.jl	/^initializer(::typeof(max), ::T) where {T} = typemin(T)$/;"	f	module:Polyester
initializer	src/Polyester.jl	/^initializer(::typeof(min), ::T) where {T} = typemax(T)$/;"	f	module:Polyester
initializer	src/Polyester.jl	/^initializer(::typeof(|), ::Bool) = false$/;"	f	module:Polyester
inner	test/runtests.jl	/^  function inner(x, y, j)$/;"	f
inner_polyester	test/runtests.jl	/^  function inner_polyester(x, y, j)$/;"	f
inner_thread	test/runtests.jl	/^  function inner_thread(x, y, j)$/;"	f
interpret_kwarg	src/closure.jl	/^function interpret_kwarg($/;"	f
issue108!	test/runtests.jl	/^function issue108!(y::Vector{T1}, x::Vector{T2}) where {T1,T2}$/;"	f
issue108_comment!	test/runtests.jl	/^function issue108_comment!(data::Vector{T}, functions) where {T}$/;"	f
issue116!	test/runtests.jl	/^function issue116!(y::Vector{T}, x::Vector{T}) where {T}$/;"	f
issue15!	test/runtests.jl	/^function issue15!(dest, src)$/;"	f
issue16!	test/runtests.jl	/^function issue16!(dest)$/;"	f
issue17!	test/runtests.jl	/^function issue17!(dest)$/;"	f
issue18!	test/runtests.jl	/^function issue18!(dest)$/;"	f
issue20!	test/runtests.jl	/^  function issue20!(dest, cache)$/;"	f
issue25!	test/runtests.jl	/^function issue25!(dest, x, y)$/;"	f
issue25_but_with_strides!	test/runtests.jl	/^function issue25_but_with_strides!(dest, x, y)$/;"	f
issue30_set!	test/runtests.jl	/^  function issue30_set!(dst)$/;"	f
issue30_throw!	test/runtests.jl	/^  function issue30_throw!(dst)$/;"	f
iterate	src/closure.jl	/^Base.iterate(::NoLoop) = (NoLoop(), NoLoop())$/;"	f	module:Base
iterate	src/closure.jl	/^Base.iterate(::NoLoop, ::NoLoop) = nothing$/;"	f	module:Base
iterate	test/runtests.jl	/^function Base.iterate(tree::LazyTree, idx = 1)$/;"	f	module:Base
lastindex	test/runtests.jl	/^Base.lastindex(e::Iterators.Enumerate{LazyTree{T}}) where {T} = lastindex(e.itr)$/;"	f	module:Base
lastindex	test/runtests.jl	/^Base.lastindex(lt::LazyTree) = length(lt)$/;"	f	module:Base
launch_batched_thread!	src/batch.jl	/^@inline function launch_batched_thread!(cfunc, tid, argtup, start, stop)$/;"	f
launch_batched_thread!	src/batch.jl	/^@inline function launch_batched_thread!(cfunc, tid, argtup, start, stop, i, reductup)$/;"	f
launch_batched_thread!	src/batch.jl	/^@inline function launch_batched_thread!(cfunc, tid, argtup, start, stop, i_or_reductup)$/;"	f
length	test/runtests.jl	/^Base.length(lt::LazyTree) = length(lt.t)$/;"	f	module:Base
load_threadlocals	src/batch.jl	/^@inline function load_threadlocals(tid, argtup::A, ::Val{S}, reductup::C) where {A,S,C}$/;"	f
makestatic!	src/closure.jl	/^function makestatic!(expr)$/;"	f
must_add_sym	src/closure.jl	/^function must_add_sym(defined::Dict{Symbol,Symbol}, arg::Symbol, mod)$/;"	f	function:define_induction_variables!
myindices	test/runtests.jl	/^myindices(x) = 1:length(x) # test hygiene, issue #11$/;"	f
myinitA	test/runtests.jl	/^  myinitA() = 0$/;"	f
myinitB	test/runtests.jl	/^  myinitB() = [0]$/;"	f
myinitD	test/runtests.jl	/^  myinitD() = Float16(1.0)$/;"	f
push_tup!	src/batch.jl	/^push_tup!(x, ::Type{NamedTuple{S,T}}, t) where {S,T<:Tuple} =$/;"	f
push_tup!	src/batch.jl	/^push_tup!(x, ::Type{T}, t) where {T<:Tuple} = push!(x, t)$/;"	f
rangemap!	test/runtests.jl	/^function rangemap!(f::F, allargs, start, stop) where {F}$/;"	f
record_start_stop!	test/runtests.jl	/^  function record_start_stop!((start_indices, end_indices), start, stop)$/;"	f
reset_threads!	src/Polyester.jl	/^function reset_threads!()$/;"	f	module:Polyester
rowsum_batch!	test/runtests.jl	/^function rowsum_batch!(x, A)$/;"	f
sequential_polyester	test/runtests.jl	/^  function sequential_polyester(x, y)$/;"	f
sequential_sequential	test/runtests.jl	/^  function sequential_sequential(x, y)$/;"	f
sequential_thread	test/runtests.jl	/^  function sequential_thread(x, y)$/;"	f
setup_batch!	src/batch.jl	/^@inline function setup_batch!($/;"	f
sin_batch_sum	test/runtests.jl	/^function sin_batch_sum(v)$/;"	f
slow_cheap	test/runtests.jl	/^  function slow_cheap(n, digits)$/;"	f
slow_single_thread	test/runtests.jl	/^  function slow_single_thread(n, digits)$/;"	f
slow_task!	test/runtests.jl	/^  function slow_task!((x, digits, n), j, k)$/;"	f
splitloop	src/closure.jl	/^@inline function splitloop($/;"	f
splitloop	src/closure.jl	/^@inline function splitloop(x::AbstractArray)$/;"	f
splitloop	src/closure.jl	/^@inline function splitloop(x::Base.Iterators.ProductIterator{Tuple{T1,T2}}) where {T1,T2}$/;"	f
splitloop	src/closure.jl	/^@inline function splitloop(x::CartesianIndices)$/;"	f
splitloop	src/closure.jl	/^@inline splitloop(x) = NoLoop(), x, CombineIndices()$/;"	f
splitloop	src/closure.jl	/^@inline splitloop(x::AbstractRange) = NoLoop(), x, CombineIndices()$/;"	f
splitloop	test/runtests.jl	/^splitloop(e::Base.Iterators.Enumerate{LazyTree{T}}) where {T} =$/;"	f
symbolsubs	src/closure.jl	/^function symbolsubs(e::Expr, old::Symbol, new::Symbol)$/;"	f	function:define_induction_variables!
symbolsubs	src/closure.jl	/^function symbolsubs(e::Symbol, old::Symbol, new::Symbol)$/;"	f	function:define_induction_variables!
symbolsubs	src/closure.jl	/^symbolsubs(e, old::Symbol, new::Symbol) = e$/;"	f	function:define_induction_variables!
t	test/runtests.jl	/^  t::T$/;"	g	struct:LazyTree
threads_of_polyester	test/runtests.jl	/^  function threads_of_polyester(x, y)$/;"	f
threads_of_polyester_inner_disable	test/runtests.jl	/^  function threads_of_polyester_inner_disable(x, y)$/;"	f
threads_of_sequential	test/runtests.jl	/^  function threads_of_sequential(x, y)$/;"	f
threads_of_thread	test/runtests.jl	/^  function threads_of_thread(x, y)$/;"	f
tmap!	test/runtests.jl	/^function tmap!(f::F, args::Vararg{AbstractArray,K}) where {K,F}$/;"	f
unwrap_type	src/closure.jl	/^unwrap_type(::WrapType{T}) where {T} = T$/;"	f
unwrap_type	src/closure.jl	/^unwrap_type(@nospecialize(x)) = x$/;"	f
update_text!	test/runtests.jl	/^  update_text!((ts, val), start, stop) = ts.vec[start:stop] .= val$/;"	f
values	test/runtests.jl	/^    values::Vector{Float64}$/;"	g	struct:Issue20
vec	test/runtests.jl	/^    vec::Vector{String}$/;"	g	struct:TestStruct
wrap_type	src/closure.jl	/^wrap_type(::Type{T}) where {T} = WrapType{T}()$/;"	f
wrap_type	src/closure.jl	/^wrap_type(@nospecialize(x)) = x$/;"	f
