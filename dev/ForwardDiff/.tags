!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FIELD_DESCRIPTION!C++	name	/aliased names/
!_TAG_FIELD_DESCRIPTION!Python	nameref	/the original name for the tag/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!C++	M,module	/modules/
!_TAG_KIND_DESCRIPTION!C++	P,partition	/partitions/
!_TAG_KIND_DESCRIPTION!C++	c,class	/classes/
!_TAG_KIND_DESCRIPTION!C++	d,macro	/macro definitions/
!_TAG_KIND_DESCRIPTION!C++	e,enumerator	/enumerators (values inside an enumeration)/
!_TAG_KIND_DESCRIPTION!C++	f,function	/function definitions/
!_TAG_KIND_DESCRIPTION!C++	g,enum	/enumeration names/
!_TAG_KIND_DESCRIPTION!C++	h,header	/included header files/
!_TAG_KIND_DESCRIPTION!C++	m,member	/class, struct, and union members/
!_TAG_KIND_DESCRIPTION!C++	n,namespace	/namespaces/
!_TAG_KIND_DESCRIPTION!C++	s,struct	/structure names/
!_TAG_KIND_DESCRIPTION!C++	t,typedef	/typedefs/
!_TAG_KIND_DESCRIPTION!C++	u,union	/union names/
!_TAG_KIND_DESCRIPTION!C++	v,variable	/variable definitions/
!_TAG_KIND_DESCRIPTION!Julia	Y,unknown	/name defined in other modules/
!_TAG_KIND_DESCRIPTION!Julia	c,constant	/Constants/
!_TAG_KIND_DESCRIPTION!Julia	f,function	/Functions/
!_TAG_KIND_DESCRIPTION!Julia	g,field	/Fields/
!_TAG_KIND_DESCRIPTION!Julia	m,macro	/Macros/
!_TAG_KIND_DESCRIPTION!Julia	n,module	/Modules/
!_TAG_KIND_DESCRIPTION!Julia	s,struct	/Structures/
!_TAG_KIND_DESCRIPTION!Julia	t,type	/Types/
!_TAG_KIND_DESCRIPTION!Make	I,makefile	/makefiles/
!_TAG_KIND_DESCRIPTION!Make	m,macro	/macros/
!_TAG_KIND_DESCRIPTION!Make	t,target	/targets/
!_TAG_KIND_DESCRIPTION!Markdown	S,subsection	/level 2 sections/
!_TAG_KIND_DESCRIPTION!Markdown	T,l4subsection	/level 4 sections/
!_TAG_KIND_DESCRIPTION!Markdown	c,chapter	/chapters/
!_TAG_KIND_DESCRIPTION!Markdown	h,hashtag	/hashtags/
!_TAG_KIND_DESCRIPTION!Markdown	n,footnote	/footnotes/
!_TAG_KIND_DESCRIPTION!Markdown	s,section	/sections/
!_TAG_KIND_DESCRIPTION!Markdown	t,subsubsection	/level 3 sections/
!_TAG_KIND_DESCRIPTION!Markdown	u,l5subsection	/level 5 sections/
!_TAG_KIND_DESCRIPTION!Python	I,namespace	/name referring a module defined in other file/
!_TAG_KIND_DESCRIPTION!Python	Y,unknown	/name referring a class\/variable\/function\/module defined in other module/
!_TAG_KIND_DESCRIPTION!Python	c,class	/classes/
!_TAG_KIND_DESCRIPTION!Python	f,function	/functions/
!_TAG_KIND_DESCRIPTION!Python	i,module	/modules/
!_TAG_KIND_DESCRIPTION!Python	m,member	/class members/
!_TAG_KIND_DESCRIPTION!Python	v,variable	/variables/
!_TAG_KIND_DESCRIPTION!Yaml	a,anchor	/anchors/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	1.1	/current.age/
!_TAG_PARSER_VERSION!C++	1.1	/current.age/
!_TAG_PARSER_VERSION!Julia	0.0	/current.age/
!_TAG_PARSER_VERSION!Make	1.1	/current.age/
!_TAG_PARSER_VERSION!Markdown	1.1	/current.age/
!_TAG_PARSER_VERSION!Python	1.1	/current.age/
!_TAG_PARSER_VERSION!Yaml	0.0	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/romeo/.julia/dev/ForwardDiff/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.2.0	/v6.2.0/
!_TAG_ROLE_DESCRIPTION!C++!header	exported	/exported with "exported imported ..."/
!_TAG_ROLE_DESCRIPTION!C++!header	imported	/imported with "imported ..."/
!_TAG_ROLE_DESCRIPTION!C++!header	local	/local header/
!_TAG_ROLE_DESCRIPTION!C++!header	system	/system header/
!_TAG_ROLE_DESCRIPTION!C++!macro	undef	/undefined/
!_TAG_ROLE_DESCRIPTION!C++!module	imported	/imported with "imported ..."/
!_TAG_ROLE_DESCRIPTION!C++!module	partOwner	/used for specifying a partition/
!_TAG_ROLE_DESCRIPTION!C++!partition	imported	/imported with "imported ..."/
!_TAG_ROLE_DESCRIPTION!Julia!module	imported	/loaded by "import"/
!_TAG_ROLE_DESCRIPTION!Julia!module	namespace	/only some symbols in it are imported/
!_TAG_ROLE_DESCRIPTION!Julia!module	used	/loaded by "using"/
!_TAG_ROLE_DESCRIPTION!Julia!unknown	imported	/loaded by "import"/
!_TAG_ROLE_DESCRIPTION!Julia!unknown	used	/loaded by "using"/
!_TAG_ROLE_DESCRIPTION!Make!makefile	included	/included/
!_TAG_ROLE_DESCRIPTION!Make!makefile	optional	/optionally included/
!_TAG_ROLE_DESCRIPTION!Python!function	entryPoint	/specified as an entry point/
!_TAG_ROLE_DESCRIPTION!Python!module	entryPoint	/specified as a module of an entry point/
!_TAG_ROLE_DESCRIPTION!Python!module	imported	/imported modules/
!_TAG_ROLE_DESCRIPTION!Python!module	indirectlyImported	/module imported in alternative name/
!_TAG_ROLE_DESCRIPTION!Python!module	namespace	/namespace from where classes\/variables\/functions are imported/
!_TAG_ROLE_DESCRIPTION!Python!unknown	imported	/imported from the other module/
!_TAG_ROLE_DESCRIPTION!Python!unknown	indirectlyImported	/classes\/variables\/functions\/modules imported in alternative name/
!_TAG_ROLE_DESCRIPTION!Yaml!anchor	alias	/alias/
A	test/ConfusionTest.jl	/^const A = rand(10,8)$/;"	c	module:ConfusionTest
AMBIGUOUS_TYPES	src/prelude.jl	/^const AMBIGUOUS_TYPES = (AbstractFloat, Irrational, Integer, Rational, Real, RoundingMode)$/;"	c
AbstractConfig	src/config.jl	/^abstract type AbstractConfig{N} end$/;"	t
Adding New Derivative Definitions	docs/src/dev/contributing.md	/^## Adding New Derivative Definitions$/;"	s	chapter:How to Contribute
Advanced Usage Guide	docs/src/user/advanced.md	/^# Advanced Usage Guide$/;"	c
AllocationsTest	test/AllocationsTest.jl	/^module AllocationsTest$/;"	n
ArithmeticStyle	src/dual.jl	/^Base.ArithmeticStyle(::Type{<:Dual{T,V}}) where {T,V} = Base.ArithmeticStyle(V)$/;"	f	module:Base
CHUNK_SIZES	test/utils.jl	/^const CHUNK_SIZES = (1, div(DEFAULT_CHUNK_THRESHOLD, 3), div(DEFAULT_CHUNK_THRESHOLD, 2), DEFAUL/;"	c
Chunk	src/prelude.jl	/^function Chunk(input_length::Integer, threshold::Integer = DEFAULT_CHUNK_THRESHOLD)$/;"	f
Chunk	src/prelude.jl	/^function Chunk(x::AbstractArray, threshold::Integer = DEFAULT_CHUNK_THRESHOLD)$/;"	f
Chunk	src/prelude.jl	/^struct Chunk{N} end$/;"	s
Configuring Chunk Size	docs/src/user/advanced.md	/^## Configuring Chunk Size$/;"	s	chapter:Advanced Usage Guide
ConfusionTest	test/ConfusionTest.jl	/^module ConfusionTest$/;"	n
Creating Differentiation Functions	docs/src/user/upgrade.md	/^## Creating Differentiation Functions$/;"	s	chapter:Retrieving Lower-Order Results
Custom tags and tag checking	docs/src/user/advanced.md	/^## Custom tags and tag checking$/;"	s	chapter:Advanced Usage Guide
DEFAULT_CHUNK_THRESHOLD	src/prelude.jl	/^const DEFAULT_CHUNK_THRESHOLD = @load_preference("default_chunk_threshold", 12)$/;"	c
DUALS	test/SIMDTest.jl	/^const DUALS = (Dual(1., 2., 3., 4.),$/;"	c	module:SIMDTest
DerivativeConfig	src/config.jl	/^function DerivativeConfig(f::F,$/;"	f
DerivativeConfig	src/config.jl	/^struct DerivativeConfig{T,D} <: AbstractConfig{1}$/;"	s
DerivativeTest	test/DerivativeTest.jl	/^module DerivativeTest$/;"	n
Derivatives of `f(x::Real)::Union{Real,AbstractArray}`	docs/src/user/api.md	/^## Derivatives of `f(x::Real)::Union{Real,AbstractArray}`$/;"	s	chapter:Differentiation API
Differentiation API	docs/src/user/api.md	/^# Differentiation API$/;"	c
Dqq̇	test/ConfusionTest.jl	/^Dqq̇(L, t, q, q̇) = ForwardDiff.jacobian(a->∂L∂q̇(L,t,a,q̇), q)$/;"	f	module:ConfusionTest
Dual	src/dual.jl	/^@inline Dual(args...) = Dual{Nothing}(args...)$/;"	f
Dual	src/dual.jl	/^struct Dual{T,V,N} <: Real$/;"	s
Dual Number Implementation	docs/src/dev/how_it_works.md	/^## Dual Number Implementation$/;"	s	chapter:How ForwardDiff Works
Dual1	benchmarks/cpp/benchmarks.h	/^class Dual1 {$/;"	c
Dual1	benchmarks/cpp/dual1.cpp	/^Dual1::Dual1() : real(0.0), eps1(0.0) {}$/;"	f	class:Dual1
Dual1	benchmarks/cpp/dual1.cpp	/^Dual1::Dual1(double real) : real(real), eps1(0.0) {}$/;"	f	class:Dual1
Dual1	benchmarks/cpp/dual1.cpp	/^Dual1::Dual1(double real, double eps1) : real(real), eps1(eps1) {}$/;"	f	class:Dual1
Dual2	benchmarks/cpp/benchmarks.h	/^class Dual2 {$/;"	c
Dual2	benchmarks/cpp/dual2.cpp	/^Dual2::Dual2() : real(0.0), eps1(0.0), eps2(0.0) {}$/;"	f	class:Dual2
Dual2	benchmarks/cpp/dual2.cpp	/^Dual2::Dual2(double real) : real(real), eps1(0.0), eps2(0.0) {}$/;"	f	class:Dual2
Dual2	benchmarks/cpp/dual2.cpp	/^Dual2::Dual2(double real, double eps1, double eps2) : real(real), eps1(eps1), eps2(eps2) {}$/;"	f	class:Dual2
Dual3	benchmarks/cpp/benchmarks.h	/^class Dual3 {$/;"	c
Dual3	benchmarks/cpp/dual3.cpp	/^Dual3::Dual3() : real(0.0), eps1(0.0), eps2(0.0), eps3(0.0) {}$/;"	f	class:Dual3
Dual3	benchmarks/cpp/dual3.cpp	/^Dual3::Dual3(double real) : real(real), eps1(0.0), eps2(0.0), eps3(0.0) {}$/;"	f	class:Dual3
Dual3	benchmarks/cpp/dual3.cpp	/^Dual3::Dual3(double real, double eps1, double eps2, double eps3) : real(real), eps1(eps1), eps2(/;"	f	class:Dual3
Dual4	benchmarks/cpp/benchmarks.h	/^class Dual4 {$/;"	c
Dual4	benchmarks/cpp/dual4.cpp	/^Dual4::Dual4() : real(0.0), eps1(0.0), eps2(0.0), eps3(0.0), eps4(0.0) {}$/;"	f	class:Dual4
Dual4	benchmarks/cpp/dual4.cpp	/^Dual4::Dual4(double real) : real(real), eps1(0.0), eps2(0.0), eps3(0.0), eps4(0.0) {}$/;"	f	class:Dual4
Dual4	benchmarks/cpp/dual4.cpp	/^Dual4::Dual4(double real, double eps1, double eps2, double eps3, double eps4) : real(real), eps1/;"	f	class:Dual4
Dual5	benchmarks/cpp/benchmarks.h	/^class Dual5 {$/;"	c
Dual5	benchmarks/cpp/dual5.cpp	/^Dual5::Dual5() : real(0.0), eps1(0.0), eps2(0.0), eps3(0.0), eps4(0.0), eps5(0.0) {}$/;"	f	class:Dual5
Dual5	benchmarks/cpp/dual5.cpp	/^Dual5::Dual5(double real) : real(real), eps1(0.0), eps2(0.0), eps3(0.0), eps4(0.0), eps5(0.0) {}$/;"	f	class:Dual5
Dual5	benchmarks/cpp/dual5.cpp	/^Dual5::Dual5(double real, double eps1, double eps2, double eps3, double eps4, double eps5) : rea/;"	f	class:Dual5
DualMismatchError	src/dual.jl	/^struct DualMismatchError{A,B} <: Exception$/;"	s
DualTest	test/DualTest.jl	/^module DualTest$/;"	n
Dual{T, V, N}	src/dual.jl	/^    function Dual{T, V, N}(value::V, partials::Partials{N, V}) where {T, V, N}$/;"	f	struct:Dual
Dual{T,V,N}	src/dual.jl	/^@inline Dual{T,V,N}(x) where {T,V,N} = convert(Dual{T,V,N}, x)$/;"	f
Dual{T,V,N}	src/dual.jl	/^@inline Dual{T,V,N}(x::Dual{T,V,N}) where {T,V,N} = x$/;"	f
Dual{T,V,N}	src/dual.jl	/^@inline Dual{T,V,N}(x::Number) where {T,V,N} = convert(Dual{T,V,N}, x)$/;"	f
Dual{T,V,N}	src/dual.jl	/^Dual{T,V,N}(x::Base.TwicePrecision) where {T,V,N} =$/;"	f
Dual{T,V}	src/dual.jl	/^@inline Dual{T,V}(x) where {T,V} = convert(Dual{T,V}, x)$/;"	f
Dual{T}	src/dual.jl	/^@inline Dual{T}(value) where {T} = Dual{T}(value, ())$/;"	f
Dual{T}	src/dual.jl	/^@inline Dual{T}(value, partial1, partials...) where {T} = Dual{T}(value, tuple(partial1, partial/;"	f
Dual{T}	src/dual.jl	/^@inline Dual{T}(value, partials::Tuple) where {T} = Dual{T}(value, Partials(partials))$/;"	f
Dual{T}	src/dual.jl	/^@inline Dual{T}(value, partials::Tuple{}) where {T} = Dual{T}(value, Partials{0,typeof(value)}(p/;"	f
Dual{T}	src/dual.jl	/^@inline Dual{T}(value::V, ::Chunk{N}, p::Val{i}) where {T,V,N,i} = Dual{T}(value, single_seed(Pa/;"	f
Dual{T}	src/dual.jl	/^@inline Dual{T}(value::V, partials::Partials{N,V}) where {T,N,V} = Dual{T,V,N}(value, partials)$/;"	f
Dual{T}	src/dual.jl	/^@inline Dual{T}(x::Dual{T}) where {T} = Dual{T}(x, ())$/;"	f
Dual{T}	src/dual.jl	/^@inline function Dual{T}(value::A, partials::Partials{N,B}) where {T,N,A,B}$/;"	f
Enabling Multithreading	docs/src/user/upgrade.md	/^# Enabling Multithreading$/;"	c
FINITEDIFF_ERROR	test/utils.jl	/^const FINITEDIFF_ERROR = 3e-5$/;"	c
Fixing NaN/Inf Issues	docs/src/user/advanced.md	/^## Fixing NaN\/Inf Issues$/;"	s	chapter:Advanced Usage Guide
ForwardDiff	docs/src/index.md	/^# ForwardDiff$/;"	c
ForwardDiff	src/ForwardDiff.jl	/^module ForwardDiff$/;"	n
ForwardDiff's API	docs/src/dev/how_it_works.md	/^## ForwardDiff's API$/;"	s	chapter:How ForwardDiff Works
ForwardDiff.jl	README.md	/^# ForwardDiff.jl$/;"	c
ForwardDiffStaticArraysExt	ext/ForwardDiffStaticArraysExt.jl	/^module ForwardDiffStaticArraysExt$/;"	n
GRAD_ERROR	src/gradient.jl	/^const GRAD_ERROR = DimensionMismatch("gradient(f, x) expects that f(x) is a real number. Perhaps/;"	c
GradientConfig	src/config.jl	/^function GradientConfig(f::F,$/;"	f
GradientConfig	src/config.jl	/^struct GradientConfig{T,V,N,D} <: AbstractConfig{N}$/;"	s
GradientTest	test/GradientTest.jl	/^module GradientTest$/;"	n
Gradients of `f(x::AbstractArray)::Real`	docs/src/user/api.md	/^## Gradients of `f(x::AbstractArray)::Real`$/;"	s	chapter:Differentiation API
HESSIAN_CHUNK_SIZES	test/utils.jl	/^const HESSIAN_CHUNK_SIZES = (1, 2, 3)$/;"	c
Hessian of a vector-valued function	docs/src/user/advanced.md	/^## Hessian of a vector-valued function$/;"	s	chapter:Advanced Usage Guide
HessianConfig	src/config.jl	/^function HessianConfig(f::F,$/;"	f
HessianConfig	src/config.jl	/^struct HessianConfig{T,V,N,DG,DJ} <: AbstractConfig{N}$/;"	s
HessianTest	test/HessianTest.jl	/^module HessianTest$/;"	n
Hessians of `f(x::AbstractArray)::Real`	docs/src/user/api.md	/^## Hessians of `f(x::AbstractArray)::Real`$/;"	s	chapter:Differentiation API
Higher-Order Differentiation	docs/src/user/upgrade.md	/^## Higher-Order Differentiation$/;"	s	chapter:Retrieving Lower-Order Results
How ForwardDiff Works	docs/src/dev/how_it_works.md	/^# How ForwardDiff Works$/;"	c
How to Contribute	docs/src/dev/contributing.md	/^# How to Contribute$/;"	c
IndexStyle	src/partials.jl	/^Base.IndexStyle(::Type{<:Partials}) = IndexLinear()$/;"	f	module:Base
InnerGradientForHess	src/hessian.jl	/^mutable struct InnerGradientForHess{R,C,F}$/;"	s
Int	src/dual.jl	/^@inline function Base.Int(d::Dual)$/;"	f	module:Base
Integer	src/dual.jl	/^@inline function Base.Integer(d::Dual)$/;"	f	module:Base
InvalidTagException	src/config.jl	/^struct InvalidTagException{E,O} <: Exception$/;"	s
JACOBIAN_ERROR	src/jacobian.jl	/^const JACOBIAN_ERROR = DimensionMismatch("jacobian(f, x) expects that f(x) is an array. Perhaps /;"	c
JacobianConfig	src/config.jl	/^function JacobianConfig(f::F,$/;"	f
JacobianConfig	src/config.jl	/^struct JacobianConfig{T,V,N,D} <: AbstractConfig{N}$/;"	s
JacobianTest	test/JacobianTest.jl	/^module JacobianTest$/;"	n
Jacobians of `f(x::AbstractArray)::AbstractArray`	docs/src/user/api.md	/^## Jacobians of `f(x::AbstractArray)::AbstractArray`$/;"	s	chapter:Differentiation API
L	test/ConfusionTest.jl	/^L(t,q,q̇) = m\/2 * dot(q̇,q̇) - m*g*q[2]$/;"	f	module:ConfusionTest
Lagrangian2Hamiltonian	test/ConfusionTest.jl	/^function Lagrangian2Hamiltonian(Lagrangian, t, q, p)$/;"	f	module:ConfusionTest
Legendre_transformation	test/ConfusionTest.jl	/^function Legendre_transformation(F, w)$/;"	f	module:ConfusionTest
Limitations of ForwardDiff	docs/src/user/limitations.md	/^# Limitations of ForwardDiff$/;"	c
MiscTest	test/MiscTest.jl	/^module MiscTest$/;"	n
NANSAFE_MODE_ENABLED	src/prelude.jl	/^const NANSAFE_MODE_ENABLED = @load_preference("nansafe_mode", false)$/;"	c
OuterTestTag	test/DualTest.jl	/^struct OuterTestTag end$/;"	s
PARTIALS_HASH	src/partials.jl	/^const PARTIALS_HASH = hash(Partials)$/;"	c
POW_DUALS	test/SIMDTest.jl	/^const POW_DUALS = (Dual(1., 2.),$/;"	c	module:SIMDTest
Partials	src/partials.jl	/^struct Partials{N,V} <: AbstractVector{V}$/;"	s
PartialsTest	test/PartialsTest.jl	/^module PartialsTest$/;"	n
Preallocating/Configuring Work Buffers	docs/src/user/api.md	/^## Preallocating\/Configuring Work Buffers$/;"	s	chapter:Differentiation API
Publications	README.md	/^## Publications$/;"	s	chapter:ForwardDiff.jl
Retrieving Lower-Order Results	docs/src/user/advanced.md	/^## Retrieving Lower-Order Results$/;"	s	chapter:Advanced Usage Guide
Retrieving Lower-Order Results	docs/src/user/upgrade.md	/^# Retrieving Lower-Order Results$/;"	c
SIMDTest	test/SIMDTest.jl	/^module SIMDTest$/;"	n
SUITE	benchmarks/benchmarks.jl	/^const SUITE = BenchmarkGroup()$/;"	c
TAGCOUNT	src/config.jl	/^const TAGCOUNT = Threads.Atomic{UInt}(0)$/;"	c
Tag	src/config.jl	/^Tag(::Nothing, ::Type{V}) where {V} = nothing$/;"	f
Tag	src/config.jl	/^function Tag(f::F, ::Type{V}) where {F,V}$/;"	f
Tag	src/config.jl	/^struct Tag{F,V}$/;"	s
TestTag	test/DualTest.jl	/^struct TestTag end$/;"	s	module:DualTest
TestTag	test/MiscTest.jl	/^struct TestTag end$/;"	s	module:MiscTest
UNARY_PREDICATES	src/prelude.jl	/^const UNARY_PREDICATES = Symbol[:isinf, :isnan, :isfinite, :iseven, :isodd, :isreal, :isinteger]$/;"	c
Unexported API Functions	docs/src/user/upgrade.md	/^# Unexported API Functions$/;"	c
Upgrading from Older Versions	docs/src/user/upgrade.md	/^# Upgrading from Older Versions$/;"	c
Upgrading to ForwardDiff.jl 1.0	README.md	/^## Upgrading to ForwardDiff.jl 1.0$/;"	s	chapter:ForwardDiff.jl
Using The `AbstractConfig` API	docs/src/user/upgrade.md	/^# Using The `AbstractConfig` API$/;"	c
X	test/utils.jl	/^const X, Y = rand(XLEN), rand(YLEN)$/;"	c
XLEN	test/utils.jl	/^const XLEN = DEFAULT_CHUNK_THRESHOLD + 1$/;"	c
YLEN	test/utils.jl	/^const YLEN = div(DEFAULT_CHUNK_THRESHOLD, 2) + 1$/;"	c
__INCLUDED__	benchmarks/cpp/benchmarks.h	/^#define __INCLUDED__$/;"	d
_diff	test/JacobianTest.jl	/^    _diff(A) = diff(A; dims=1)$/;"	f	module:JacobianTest
_div_partials	src/partials.jl	/^@inline function _div_partials(a::Partials, b::Partials, aval, bval)$/;"	f
_eigen	src/dual.jl	/^function _eigen(A::Symmetric{<:Dual{Tg,T,N}}) where {Tg,T<:Real,N}$/;"	f
_eigvals	src/dual.jl	/^function _eigvals(A::Symmetric{<:Dual{Tg,T,N}}) where {Tg,T<:Real,N}$/;"	f
_lyap_div!	src/dual.jl	/^function _lyap_div!(A::AbstractMatrix, λ::AbstractVector)$/;"	f
_lyap_div!!	ext/ForwardDiffStaticArraysExt.jl	/^ForwardDiff._lyap_div!!(A::StaticArrays.MMatrix, λ::AbstractVector) = ForwardDiff._lyap_div!(A,/;"	f	module:ForwardDiff
_lyap_div!!	src/dual.jl	/^_lyap_div!!(A::Matrix, λ::AbstractVector) = _lyap_div!(A, λ)$/;"	f
_lyap_div!!	src/dual.jl	/^function _lyap_div!!(A::AbstractMatrix, λ::AbstractVector)$/;"	f
_mul_partials	src/partials.jl	/^    @inline function _mul_partials(a::Partials{N}, b::Partials{N}, x_a, x_b) where N$/;"	f
_mul_partials	src/partials.jl	/^@inline _mul_partials(a::Partials{0,A}, b::Partials{0,B}, afactor, bfactor) where {A,B} = Partia/;"	f
_mul_partials	src/partials.jl	/^@inline _mul_partials(a::Partials{0,A}, b::Partials{N,B}, afactor, bfactor) where {N,A,B} = bfac/;"	f
_mul_partials	src/partials.jl	/^@inline _mul_partials(a::Partials{N,A}, b::Partials{0,B}, afactor, bfactor) where {N,A,B} = afac/;"	f
a	src/dual.jl	/^    a::A$/;"	g	struct:DualMismatchError
ackley	benchmarks/cpp/benchmarks.cpp	/^template <typename T> T ackley(const std::vector<T> &x) {$/;"	f	typeref:typename:T
ackley	benchmarks/py/algopy_benchmarks.py	/^def ackley(x):$/;"	f
ackley	benchmarks/py/autograd_benchmarks.py	/^def ackley(x):$/;"	f
add_tuples	src/partials.jl	/^@generated function add_tuples(a::NTuple{N}, b::NTuple{N})  where N$/;"	f
all	benchmarks/cpp/Makefile	/^all:$/;"	t
b	src/dual.jl	/^    b::B$/;"	g	struct:DualMismatchError
bench	benchmarks/py/algopy_benchmarks.py	/^def bench(f, x, repeat):$/;"	f
bench	benchmarks/py/autograd_benchmarks.py	/^def bench(f, x, r, n):$/;"	f
binary_dual_definition	src/dual.jl	/^function binary_dual_definition(M, f)$/;"	f
calc_fma_xy	src/dual.jl	/^@inline function calc_fma_xy(x::Dual{T}, y::Dual{T}, z::Real) where T$/;"	f
calc_fma_xyz	src/dual.jl	/^@generated function calc_fma_xyz(x::Dual{T,<:Any,N},$/;"	f
calc_fma_xz	src/dual.jl	/^@generated function calc_fma_xz(x::Dual{T,<:Any,N},$/;"	f
calc_hypot	src/dual.jl	/^@inline function calc_hypot(x, y, z, ::Type{T}) where T$/;"	f
calc_muladd_xy	src/dual.jl	/^@inline function calc_muladd_xy(x::Dual{T}, y::Dual{T}, z::Real) where T$/;"	f
calc_muladd_xyz	src/dual.jl	/^@generated function calc_muladd_xyz(x::Dual{T,<:Any,N},$/;"	f
calc_muladd_xz	src/dual.jl	/^@generated function calc_muladd_xz(x::Dual{T,<:Any,N},$/;"	f
can_dual	src/dual.jl	/^can_dual(::Type) = false$/;"	f
can_dual	src/dual.jl	/^can_dual(::Type{<:Real}) = true$/;"	f
ceil	src/dual.jl	/^Base.ceil(::Type{R}, d::Dual) where {R<:Real} = ceil(R, value(d))$/;"	f	module:Base
ceil	src/dual.jl	/^Base.ceil(d::Dual) = ceil(value(d))$/;"	f	module:Base
cfg	src/hessian.jl	/^    cfg::C$/;"	g	struct:InnerGradientForHess
checktag	src/config.jl	/^checktag(::DerivativeConfig{T},f,x) where {T} = checktag(T,f,x)$/;"	f
checktag	src/config.jl	/^checktag(::GradientConfig{T},f,x) where {T} = checktag(T,f,x)$/;"	f
checktag	src/config.jl	/^checktag(::HessianConfig{T},f,x) where {T} = checktag(T,f,x)$/;"	f
checktag	src/config.jl	/^checktag(::JacobianConfig{T},f,x) where {T} = checktag(T,f,x)$/;"	f
checktag	src/config.jl	/^checktag(::Type{Tag{F,V}}, f::F, x::AbstractArray{V}) where {F,V} = true$/;"	f
checktag	src/config.jl	/^checktag(::Type{Tag{FT,VT}}, f::F, x::AbstractArray{V}) where {FT,VT,F,V} =$/;"	f
checktag	src/config.jl	/^checktag(::Type{Tag{FT,VT}}, f::F, x::AbstractArray{V}) where {FT<:Tuple,VT,F,V} = true$/;"	f
checktag	src/config.jl	/^checktag(z, f, x) = true$/;"	f
chunk_mode_gradient	src/gradient.jl	/^@eval function chunk_mode_gradient(f::F, x, cfg::GradientConfig{T,V,N}) where {F,T,V,N}$/;"	f
chunk_mode_gradient!	src/gradient.jl	/^@eval function chunk_mode_gradient!(result, f::F, x, cfg::GradientConfig{T,V,N}) where {F,T,V,N}$/;"	f
chunk_mode_gradient_expr	src/gradient.jl	/^function chunk_mode_gradient_expr(result_definition::Expr)$/;"	f
chunk_mode_jacobian	src/jacobian.jl	/^@eval function chunk_mode_jacobian(f!::F, y, x, cfg::JacobianConfig{T,V,N}) where {F,T,V,N}$/;"	f
chunk_mode_jacobian	src/jacobian.jl	/^@eval function chunk_mode_jacobian(f::F, x, cfg::JacobianConfig{T,V,N}) where {F,T,V,N}$/;"	f
chunk_mode_jacobian!	src/jacobian.jl	/^@eval function chunk_mode_jacobian!(result, f!::F, y, x, cfg::JacobianConfig{T,V,N}) where {F,T,/;"	f
chunk_mode_jacobian!	src/jacobian.jl	/^@eval function chunk_mode_jacobian!(result, f::F, x, cfg::JacobianConfig{T,V,N}) where {F,T,V,N}$/;"	f
chunksize	src/prelude.jl	/^chunksize(::Chunk{N}) where {N} = N$/;"	f
cld	src/dual.jl	/^Base.cld(x::Dual, y::Dual) = cld(value(x), value(y))$/;"	f	module:Base
clock_now	benchmarks/cpp/benchmarks.cpp	/^double clock_now()$/;"	f	typeref:typename:double
construct_seeds	src/apiutils.jl	/^@generated function construct_seeds(::Type{Partials{N,V}}) where {N,V}$/;"	f
convert	src/dual.jl	/^@inline Base.convert(::Type{Dual{T,Dual{T,V,M},N}}, d::Dual{T,V,M}) where {T,V,N,M} = Dual{T}(d,/;"	f	module:Base
convert	src/dual.jl	/^@inline Base.convert(::Type{Dual{T,V,N}}, d::Dual{T}) where {T,V,N} = Dual{T}(V(value(d)), conve/;"	f	module:Base
convert	src/dual.jl	/^@inline Base.convert(::Type{Dual{T,V,N}}, x) where {T,V,N} = Dual{T}(V(x), zero(Partials{N,V}))$/;"	f	module:Base
convert	src/dual.jl	/^@inline Base.convert(::Type{Dual{T,V,N}}, x::Number) where {T,V,N} = Dual{T}(V(x), zero(Partials/;"	f	module:Base
convert	src/dual.jl	/^Base.convert(::Type{D}, d::D) where {D<:Dual} = d$/;"	f	module:Base
convert	src/partials.jl	/^Base.convert(::Type{Partials{N,V}}, partials::Partials) where {N,V} = Partials{N,V}(partials.val/;"	f	module:Base
convert	src/partials.jl	/^Base.convert(::Type{Partials{N,V}}, partials::Partials{N,V}) where {N,V} = partials$/;"	f	module:Base
convert_test_574	test/AllocationsTest.jl	/^convert_test_574() = convert(ForwardDiff.Dual{Nothing,ForwardDiff.Dual{Nothing,ForwardDiff.Dual{/;"	f	module:AllocationsTest
copy	src/config.jl	/^Base.copy(cfg::AbstractConfig) = deepcopy(cfg)$/;"	f	module:Base
copy	src/dual.jl	/^Base.copy(d::Dual) = d$/;"	f	module:Base
copy	src/partials.jl	/^@inline Base.copy(partials::Partials) = partials$/;"	f	module:Base
copy_value!	src/apiutils.jl	/^@inline copy_value!(out, y) = out$/;"	f
copy_value!	src/apiutils.jl	/^@inline copy_value!(out::DiffResult, y) = DiffResults.value!(out, y)$/;"	f
cos	benchmarks/cpp/dual1.cpp	/^Dual1 cos(const Dual1& x) {$/;"	f	typeref:typename:Dual1
cos	benchmarks/cpp/dual2.cpp	/^Dual2 cos(const Dual2& x) {$/;"	f	typeref:typename:Dual2
cos	benchmarks/cpp/dual3.cpp	/^Dual3 cos(const Dual3& x) {$/;"	f	typeref:typename:Dual3
cos	benchmarks/cpp/dual4.cpp	/^Dual4 cos(const Dual4& x) {$/;"	f	typeref:typename:Dual4
cos	benchmarks/cpp/dual5.cpp	/^Dual5 cos(const Dual5& x) {$/;"	f	typeref:typename:Dual5
cos	src/dual.jl	/^function Base.cos(d::Dual{T}) where T$/;"	f	module:Base
define_binary_dual_op	src/dual.jl	/^macro define_binary_dual_op(f, xy_body, x_body, y_body)$/;"	m
define_ternary_dual_op	src/dual.jl	/^macro define_ternary_dual_op(f, xyz_body, xy_body, xz_body, yz_body, x_body, y_body, z_body)$/;"	m
derivative	src/derivative.jl	/^@inline function derivative(f!::F, y::AbstractArray, x::Real,$/;"	f
derivative	src/derivative.jl	/^@inline function derivative(f::F, x::R) where {F,R<:Real}$/;"	f
derivative	src/derivative.jl	/^derivative(f, x::AbstractArray) = throw(DimensionMismatch("derivative(f, x) expects that x is a /;"	f
derivative	src/derivative.jl	/^derivative(f, x::Complex) = throw(DimensionMismatch("derivative(f, x) expects that x is a real n/;"	f
derivative!	src/derivative.jl	/^@inline function derivative!(result::Union{AbstractArray,DiffResult},$/;"	f
derivative_group	benchmarks/benchmarks.jl	/^const derivative_group = addgroup!(SUITE, "derivative")$/;"	c
det2	test/GradientTest.jl	/^    det2(A) = return ($/;"	f	module:GradientTest
div	src/dual.jl	/^Base.div(x::Dual, y::Dual, r::RoundingMode) = div(value(x), value(y), r)$/;"	f	module:Base
div_tuple_by_scalar	src/partials.jl	/^@generated function div_tuple_by_scalar(tup::NTuple{N}, x) where N$/;"	f
dual_definition_retval	src/dual.jl	/^function dual_definition_retval(::Val{T}, val::Complex, deriv1::Union{Real,Complex}, partial1::P/;"	f
dual_definition_retval	src/dual.jl	/^function dual_definition_retval(::Val{T}, val::Complex, deriv::Union{Real,Complex}, partial::Par/;"	f
dual_definition_retval	src/dual.jl	/^function dual_definition_retval(::Val{T}, val::Real, deriv1::Real, partial1::Partials, deriv2::R/;"	f
dual_definition_retval	src/dual.jl	/^function dual_definition_retval(::Val{T}, val::Real, deriv::Real, partial::Partials) where {T}$/;"	f
dual_isapprox	test/DualTest.jl	/^dual_isapprox(a, b) = isapprox(a, b)$/;"	f
dual_isapprox	test/DualTest.jl	/^dual_isapprox(a::Dual{T,T1,T2}, b::Dual{T,T3,T4}) where {T,T1,T2,T3,T4} = isapprox(value(a), val/;"	f
dual_isapprox	test/DualTest.jl	/^dual_isapprox(a::Dual{T,T1,T2}, b::Dual{T3,T4,T5}) where {T,T1,T2,T3,T4,T5} = error("Tags don't /;"	f
dualize	ext/ForwardDiffStaticArraysExt.jl	/^@generated function dualize(::Type{T}, x::StaticArray) where T$/;"	f	module:ForwardDiffStaticArraysExt
duals	src/config.jl	/^    duals::D$/;"	g	struct:DerivativeConfig
duals	src/config.jl	/^    duals::D$/;"	g	struct:GradientConfig
duals	src/config.jl	/^    duals::D$/;"	g	struct:JacobianConfig
eigen	ext/ForwardDiffStaticArraysExt.jl	/^function LinearAlgebra.eigen(A::Symmetric{<:Dual{Tg,T,N}, <:StaticArrays.StaticMatrix}) where {T/;"	f	module:LinearAlgebra
eigen	src/dual.jl	/^LinearAlgebra.eigen(A::Symmetric{<:Dual{Tg,T,N}}) where {Tg,T<:Real,N} = _eigen(A)$/;"	f	module:LinearAlgebra
eigen	src/dual.jl	/^function LinearAlgebra.eigen(A::SymTridiagonal{<:Dual{Tg,T,N}}) where {Tg,T<:Real,N}$/;"	f	module:LinearAlgebra
eigvals	ext/ForwardDiffStaticArraysExt.jl	/^function LinearAlgebra.eigvals(A::Symmetric{<:Dual{Tg,T,N}, <:StaticArrays.StaticMatrix}) where /;"	f	module:LinearAlgebra
eigvals	src/dual.jl	/^LinearAlgebra.eigvals(A::Symmetric{<:Dual{Tg,T,N}}) where {Tg,T<:Real,N} = _eigvals(A)$/;"	f	module:LinearAlgebra
eigvals	src/dual.jl	/^function LinearAlgebra.eigvals(A::Hermitian{<:Complex{<:Dual{Tg,T,N}}}) where {Tg,T<:Real,N}$/;"	f	module:LinearAlgebra
eigvals	src/dual.jl	/^function LinearAlgebra.eigvals(A::SymTridiagonal{<:Dual{Tg,T,N}}) where {Tg,T<:Real,N}$/;"	f	module:LinearAlgebra
eltype	src/config.jl	/^Base.eltype(::Type{DerivativeConfig{T,D}}) where {T,D} = eltype(D)$/;"	f	module:Base
eltype	src/config.jl	/^Base.eltype(::Type{GradientConfig{T,V,N,D}}) where {T,V,N,D} = Dual{T,V,N}$/;"	f	module:Base
eltype	src/config.jl	/^Base.eltype(::Type{HessianConfig{T,V,N,DG,DJ}}) where {T,V,N,DG,DJ} =$/;"	f	module:Base
eltype	src/config.jl	/^Base.eltype(::Type{JacobianConfig{T,V,N,D}}) where {T,V,N,D} = Dual{T,V,N}$/;"	f	module:Base
eltype	src/config.jl	/^Base.eltype(cfg::AbstractConfig) = eltype(typeof(cfg))$/;"	f	module:Base
eps	src/dual.jl	/^Base.eps(::Type{D}) where {D<:Dual} = eps(valtype(D))$/;"	f	module:Base
eps	src/dual.jl	/^Base.eps(d::Dual) = eps(value(d))$/;"	f	module:Base
eps1	benchmarks/cpp/benchmarks.h	/^    double eps1;$/;"	m	class:Dual1	typeref:typename:double
eps1	benchmarks/cpp/benchmarks.h	/^    double eps1;$/;"	m	class:Dual2	typeref:typename:double
eps1	benchmarks/cpp/benchmarks.h	/^    double eps1;$/;"	m	class:Dual3	typeref:typename:double
eps1	benchmarks/cpp/benchmarks.h	/^    double eps1;$/;"	m	class:Dual4	typeref:typename:double
eps1	benchmarks/cpp/benchmarks.h	/^    double eps1;$/;"	m	class:Dual5	typeref:typename:double
eps2	benchmarks/cpp/benchmarks.h	/^    double eps2;$/;"	m	class:Dual2	typeref:typename:double
eps2	benchmarks/cpp/benchmarks.h	/^    double eps2;$/;"	m	class:Dual3	typeref:typename:double
eps2	benchmarks/cpp/benchmarks.h	/^    double eps2;$/;"	m	class:Dual4	typeref:typename:double
eps2	benchmarks/cpp/benchmarks.h	/^    double eps2;$/;"	m	class:Dual5	typeref:typename:double
eps3	benchmarks/cpp/benchmarks.h	/^    double eps3;$/;"	m	class:Dual3	typeref:typename:double
eps3	benchmarks/cpp/benchmarks.h	/^    double eps3;$/;"	m	class:Dual4	typeref:typename:double
eps3	benchmarks/cpp/benchmarks.h	/^    double eps3;$/;"	m	class:Dual5	typeref:typename:double
eps4	benchmarks/cpp/benchmarks.h	/^    double eps4;$/;"	m	class:Dual4	typeref:typename:double
eps4	benchmarks/cpp/benchmarks.h	/^    double eps4;$/;"	m	class:Dual5	typeref:typename:double
eps5	benchmarks/cpp/benchmarks.h	/^    double eps5;$/;"	m	class:Dual5	typeref:typename:double
ev1	test/JacobianTest.jl	/^    ev1(x) = eigen(Symmetric(x*x')).vectors[:,1]$/;"	f	module:JacobianTest
ev2	test/JacobianTest.jl	/^    ev2(x) = eigen(SymTridiagonal(x, x[1:end-1])).vectors[:,1]$/;"	f	module:JacobianTest
exp	benchmarks/cpp/dual1.cpp	/^Dual1 exp(const Dual1& x) {$/;"	f	typeref:typename:Dual1
exp	benchmarks/cpp/dual2.cpp	/^Dual2 exp(const Dual2& x) {$/;"	f	typeref:typename:Dual2
exp	benchmarks/cpp/dual3.cpp	/^Dual3 exp(const Dual3& x) {$/;"	f	typeref:typename:Dual3
exp	benchmarks/cpp/dual4.cpp	/^Dual4 exp(const Dual4& x) {$/;"	f	typeref:typename:Dual4
exp	benchmarks/cpp/dual5.cpp	/^Dual5 exp(const Dual5& x) {$/;"	f	typeref:typename:Dual5
exponent	src/dual.jl	/^Base.exponent(x::Dual) = exponent(value(x))$/;"	f	module:Base
extract_derivative	src/derivative.jl	/^@inline extract_derivative(::Type{T}, y::AbstractArray) where {T} = map(d -> extract_derivative(/;"	f
extract_derivative	src/derivative.jl	/^@inline extract_derivative(::Type{T}, y::Complex) where {T}       = zero(y)$/;"	f
extract_derivative	src/derivative.jl	/^@inline extract_derivative(::Type{T}, y::Dual) where {T}          = partials(T, y, 1)$/;"	f
extract_derivative	src/derivative.jl	/^@inline extract_derivative(::Type{T}, y::Real) where {T}          = zero(y)$/;"	f
extract_derivative	src/derivative.jl	/^@inline function extract_derivative(::Type{T}, y::Complex{TD}) where {T, TD <: Dual}$/;"	f
extract_derivative!	src/derivative.jl	/^extract_derivative!(::Type{T}, result::AbstractArray, y::AbstractArray) where {T} =$/;"	f
extract_derivative!	src/derivative.jl	/^extract_derivative!(::Type{T}, result::DiffResult, y) where {T} =$/;"	f
extract_gradient	ext/ForwardDiffStaticArraysExt.jl	/^@generated function extract_gradient(::Type{T}, y::Real, x::S) where {T,S<:StaticArray}$/;"	f	module:ForwardDiffStaticArraysExt
extract_gradient!	src/gradient.jl	/^extract_gradient!(::Type{T}, result::AbstractArray, y::Real) where {T} = fill!(result, zero(y))$/;"	f
extract_gradient!	src/gradient.jl	/^function extract_gradient!(::Type{T}, result::AbstractArray, dual::Dual) where {T}$/;"	f
extract_gradient!	src/gradient.jl	/^function extract_gradient!(::Type{T}, result::DiffResult, dual::Dual) where {T}$/;"	f
extract_gradient!	src/gradient.jl	/^function extract_gradient!(::Type{T}, result::DiffResult, y::Real) where {T}$/;"	f
extract_gradient_chunk!	src/gradient.jl	/^extract_gradient_chunk!(::Type, result, dual::AbstractArray, index, chunksize) = throw(GRAD_ERRO/;"	f
extract_gradient_chunk!	src/gradient.jl	/^extract_gradient_chunk!(::Type, result::DiffResult, dual::AbstractArray, index, chunksize) = thr/;"	f
extract_gradient_chunk!	src/gradient.jl	/^function extract_gradient_chunk!(::Type{T}, result, dual, index, chunksize) where {T}$/;"	f
extract_gradient_chunk!	src/gradient.jl	/^function extract_gradient_chunk!(::Type{T}, result::DiffResult, dual, index, chunksize) where {T/;"	f
extract_jacobian	ext/ForwardDiffStaticArraysExt.jl	/^@generated function extract_jacobian(::Type{T}, ydual::StaticArray, x::S) where {T,S<:StaticArra/;"	f	module:ForwardDiffStaticArraysExt
extract_jacobian	ext/ForwardDiffStaticArraysExt.jl	/^function extract_jacobian(::Type{T}, ydual::AbstractArray, x::StaticArray) where T$/;"	f	module:ForwardDiffStaticArraysExt
extract_jacobian!	src/jacobian.jl	/^function extract_jacobian!(::Type{T}, result::AbstractArray, ydual::AbstractArray, n) where {T}$/;"	f
extract_jacobian!	src/jacobian.jl	/^function extract_jacobian!(::Type{T}, result::MutableDiffResult, ydual::AbstractArray, n) where /;"	f
extract_jacobian_chunk!	src/jacobian.jl	/^function extract_jacobian_chunk!(::Type{T}, result, ydual, index, chunksize) where {T}$/;"	f
extract_value!	src/apiutils.jl	/^@inline extract_value!(::Type{T}, out, ydual) where {T} = out # ???$/;"	f
extract_value!	src/apiutils.jl	/^@inline extract_value!(::Type{T}, out::DiffResult, ydual) where {T} =$/;"	f
extract_value!	src/apiutils.jl	/^@inline function extract_value!(::Type{T}, out, y, ydual) where {T}$/;"	f
f	src/hessian.jl	/^    f::F$/;"	g	struct:InnerGradientForHess
f	test/GradientTest.jl	/^    function f(p)$/;"	f	module:GradientTest
f	test/JacobianTest.jl	/^        f(x) = SA[x[1]^2+x[2]^2, x[2]^2+x[3]^2]$/;"	f	module:JacobianTest
f	test/JacobianTest.jl	/^        f(x) = x .^ 2 .\/ 2$/;"	f	module:JacobianTest
f267	test/MiscTest.jl	/^@noinline f267(z, x) = x[1]$/;"	f
f83a	test/ConfusionTest.jl	/^@noinline f83a(z, x) = x[1]$/;"	f	module:ConfusionTest
f_const	test/GradientTest.jl	/^    f_const(x) = 1.0$/;"	f	module:GradientTest
fld	src/dual.jl	/^Base.fld(x::Dual, y::Dual) = fld(value(x), value(y))$/;"	f	module:Base
float	src/dual.jl	/^Base.float(::Type{Dual{T,V,N}}) where {T,V,N} = Dual{T,float(V),N}$/;"	f	module:Base
float	src/dual.jl	/^Base.float(d::Dual) = convert(float(typeof(d)), d)$/;"	f	module:Base
floor	src/dual.jl	/^Base.floor(::Type{R}, d::Dual) where {R<:Real} = floor(R, value(d))$/;"	f	module:Base
floor	src/dual.jl	/^Base.floor(d::Dual) = floor(value(d))$/;"	f	module:Base
g!	test/JacobianTest.jl	/^    g!(dy, y) = dy[1] = y[1]$/;"	f	module:JacobianTest
gamma_inc	src/dual.jl	/^function SpecialFunctions.gamma_inc(a::Real, d::Dual{T,<:Real}, ind::Integer) where {T}$/;"	f	module:SpecialFunctions
getindex	src/partials.jl	/^@inline Base.@propagate_inbounds Base.getindex(partials::Partials, i::Int) = partials.values[i]$/;"	f	module:Base
gradf	benchmarks/py/algopy_benchmarks.py	/^    def gradf(x):$/;"	f	function:gradient	file:
gradient	benchmarks/cpp/benchmarks.h	/^template <Dual1 (*F)(const std::vector<Dual1> &)> void gradient(std::vector<double> &result, std/;"	f	typeref:typename:void
gradient	benchmarks/cpp/benchmarks.h	/^template <Dual2 (*F)(const std::vector<Dual2> &)> void gradient(std::vector<double> &result, std/;"	f	typeref:typename:void
gradient	benchmarks/cpp/benchmarks.h	/^template <Dual3 (*F)(const std::vector<Dual3> &)> void gradient(std::vector<double> &result, std/;"	f	typeref:typename:void
gradient	benchmarks/cpp/benchmarks.h	/^template <Dual4 (*F)(const std::vector<Dual4> &)> void gradient(std::vector<double> &result, std/;"	f	typeref:typename:void
gradient	benchmarks/cpp/benchmarks.h	/^template <Dual5 (*F)(const std::vector<Dual5> &)> void gradient(std::vector<double> &result, std/;"	f	typeref:typename:void
gradient	benchmarks/py/algopy_benchmarks.py	/^def gradient(f):$/;"	f
gradient	ext/ForwardDiffStaticArraysExt.jl	/^@inline ForwardDiff.gradient(f::F, x::StaticArray) where {F} = vector_mode_gradient(f, x)$/;"	f	module:ForwardDiff
gradient	ext/ForwardDiffStaticArraysExt.jl	/^@inline ForwardDiff.gradient(f::F, x::StaticArray, cfg::GradientConfig) where {F} = gradient(f, /;"	f	module:ForwardDiff
gradient	ext/ForwardDiffStaticArraysExt.jl	/^@inline ForwardDiff.gradient(f::F, x::StaticArray, cfg::GradientConfig, ::Val) where {F} = gradi/;"	f	module:ForwardDiff
gradient	src/gradient.jl	/^function gradient(f::F, x::AbstractArray, cfg::GradientConfig{T} = GradientConfig(f, x), ::Val{C/;"	f
gradient	src/gradient.jl	/^gradient(f, x::Real) = throw(DimensionMismatch("gradient(f, x) expects that x is an array. Perha/;"	f
gradient!	ext/ForwardDiffStaticArraysExt.jl	/^@inline ForwardDiff.gradient!(result::Union{AbstractArray,DiffResult}, f::F, x::StaticArray) whe/;"	f	module:ForwardDiff
gradient!	ext/ForwardDiffStaticArraysExt.jl	/^@inline ForwardDiff.gradient!(result::Union{AbstractArray,DiffResult}, f::F, x::StaticArray, cfg/;"	f	module:ForwardDiff
gradient!	src/gradient.jl	/^function gradient!(result::Union{AbstractArray,DiffResult}, f::F, x::AbstractArray, cfg::Gradien/;"	f
gradient_config	src/config.jl	/^    gradient_config::GradientConfig{T,Dual{T,V,N},N,DG}$/;"	g	struct:HessianConfig
gradient_group	benchmarks/benchmarks.jl	/^const gradient_group = addgroup!(SUITE, "gradient")$/;"	c
hash	src/dual.jl	/^Base.hash(d::Dual, hsh::UInt) = hash(value(d), hsh)$/;"	f	module:Base
hash	src/partials.jl	/^Base.hash(partials::Partials, hsh::UInt64) = hash(hash(partials.values, PARTIALS_HASH), hsh)$/;"	f	module:Base
hessf	benchmarks/py/algopy_benchmarks.py	/^    def hessf(x):$/;"	f	function:hessian	file:
hessian	benchmarks/py/algopy_benchmarks.py	/^def hessian(f):$/;"	f
hessian	ext/ForwardDiffStaticArraysExt.jl	/^ForwardDiff.hessian(f::F, x::StaticArray) where {F} = jacobian(Base.Fix1(gradient, f), x)$/;"	f	module:ForwardDiff
hessian	ext/ForwardDiffStaticArraysExt.jl	/^ForwardDiff.hessian(f::F, x::StaticArray, cfg::HessianConfig) where {F} = hessian(f, x)$/;"	f	module:ForwardDiff
hessian	ext/ForwardDiffStaticArraysExt.jl	/^ForwardDiff.hessian(f::F, x::StaticArray, cfg::HessianConfig, ::Val) where {F} = hessian(f, x)$/;"	f	module:ForwardDiff
hessian	src/hessian.jl	/^function hessian(f::F, x::AbstractArray, cfg::HessianConfig{T} = HessianConfig(f, x), ::Val{CHK}/;"	f
hessian!	ext/ForwardDiffStaticArraysExt.jl	/^ForwardDiff.hessian!(result::AbstractArray, f::F, x::StaticArray) where {F} = jacobian!(result, /;"	f	module:ForwardDiff
hessian!	ext/ForwardDiffStaticArraysExt.jl	/^ForwardDiff.hessian!(result::ImmutableDiffResult, f::F, x::StaticArray, cfg::HessianConfig) wher/;"	f	module:ForwardDiff
hessian!	ext/ForwardDiffStaticArraysExt.jl	/^ForwardDiff.hessian!(result::ImmutableDiffResult, f::F, x::StaticArray, cfg::HessianConfig, ::Va/;"	f	module:ForwardDiff
hessian!	ext/ForwardDiffStaticArraysExt.jl	/^ForwardDiff.hessian!(result::MutableDiffResult, f::F, x::StaticArray) where {F} = hessian!(resul/;"	f	module:ForwardDiff
hessian!	ext/ForwardDiffStaticArraysExt.jl	/^function ForwardDiff.hessian!(result::ImmutableDiffResult, f::F, x::StaticArray) where {F}$/;"	f	module:ForwardDiff
hessian!	src/hessian.jl	/^function hessian!(result::AbstractArray, f::F, x::AbstractArray, cfg::HessianConfig{T} = Hessian/;"	f
hessian!	src/hessian.jl	/^function hessian!(result::DiffResult, f::F, x::AbstractArray, cfg::HessianConfig{T} = HessianCon/;"	f
hessian_group	benchmarks/benchmarks.jl	/^const hessian_group = addgroup!(SUITE, "hessian")$/;"	c
intrand	test/DualTest.jl	/^intrand(V) = V == Int ? rand(2:10) : rand(V)$/;"	f
intrand	test/MiscTest.jl	/^intrand(V) = V == Int ? rand(2:10) : rand(V)$/;"	f
isconstant	src/dual.jl	/^isconstant(d::Dual) = iszero(partials(d))$/;"	f
isequal	src/partials.jl	/^Base.isequal(a::Partials{N}, b::Partials{N}) where {N} = isequal(a.values, b.values)$/;"	f	module:Base
iszero	src/dual.jl	/^Base.iszero(x::Dual) = iszero(value(x)) && iszero(partials(x))  # shortcut, equivalent to x == z/;"	f	module:Base
iszero	src/partials.jl	/^@inline Base.iszero(partials::Partials) = iszero_tuple(partials.values)$/;"	f	module:Base
iszero_tuple	src/partials.jl	/^@generated function iszero_tuple(tup::NTuple{N,V}) where {N,V}$/;"	f
iszero_tuple	src/partials.jl	/^@inline iszero_tuple(::Tuple{}) = true$/;"	f
iterate	src/partials.jl	/^Base.iterate(partials::Partials) = iterate(partials.values)$/;"	f	module:Base
iterate	src/partials.jl	/^Base.iterate(partials::Partials, i) = iterate(partials.values, i)$/;"	f	module:Base
jacobian	ext/ForwardDiffStaticArraysExt.jl	/^@inline ForwardDiff.jacobian(f::F, x::StaticArray) where {F} = vector_mode_jacobian(f, x)$/;"	f	module:ForwardDiff
jacobian	ext/ForwardDiffStaticArraysExt.jl	/^@inline ForwardDiff.jacobian(f::F, x::StaticArray, cfg::JacobianConfig) where {F} = jacobian(f, /;"	f	module:ForwardDiff
jacobian	ext/ForwardDiffStaticArraysExt.jl	/^@inline ForwardDiff.jacobian(f::F, x::StaticArray, cfg::JacobianConfig, ::Val) where {F} = jacob/;"	f	module:ForwardDiff
jacobian	src/jacobian.jl	/^function jacobian(f!::F, y::AbstractArray, x::AbstractArray, cfg::JacobianConfig{T} = JacobianCo/;"	f
jacobian	src/jacobian.jl	/^function jacobian(f::F, x::AbstractArray, cfg::JacobianConfig{T} = JacobianConfig(f, x), ::Val{C/;"	f
jacobian	src/jacobian.jl	/^jacobian(f, x::Real) = throw(DimensionMismatch("jacobian(f, x) expects that x is an array. Perha/;"	f
jacobian!	ext/ForwardDiffStaticArraysExt.jl	/^@inline ForwardDiff.jacobian!(result::Union{AbstractArray,DiffResult}, f::F, x::StaticArray) whe/;"	f	module:ForwardDiff
jacobian!	ext/ForwardDiffStaticArraysExt.jl	/^@inline ForwardDiff.jacobian!(result::Union{AbstractArray,DiffResult}, f::F, x::StaticArray, cfg/;"	f	module:ForwardDiff
jacobian!	src/jacobian.jl	/^function jacobian!(result::Union{AbstractArray,DiffResult}, f!::F, y::AbstractArray, x::Abstract/;"	f
jacobian!	src/jacobian.jl	/^function jacobian!(result::Union{AbstractArray,DiffResult}, f::F, x::AbstractArray, cfg::Jacobia/;"	f
jacobian_chunk_mode_expr	src/jacobian.jl	/^function jacobian_chunk_mode_expr(work_array_definition::Expr, compute_ydual::Expr,$/;"	f
jacobian_config	src/config.jl	/^    jacobian_config::JacobianConfig{T,V,N,DJ}$/;"	g	struct:HessianConfig
jacobian_group	benchmarks/benchmarks.jl	/^const jacobian_group = addgroup!(SUITE, "jacobian")$/;"	c
length	src/partials.jl	/^@inline Base.length(::Partials{N}) where {N} = N$/;"	f	module:Base
literal_pow	src/dual.jl	/^    @eval @inline function Base.literal_pow(::typeof(^), x::Dual{T}, ::Val{$y}) where {T}$/;"	f	module:Base
literal_pow	src/dual.jl	/^@inline Base.literal_pow(::typeof(^), x::Dual{T}, ::Val{0}) where {T} =$/;"	f	module:Base
logabsgamma	src/dual.jl	/^function SpecialFunctions.logabsgamma(d::Dual{T,<:Real}) where {T}$/;"	f	module:SpecialFunctions
main	benchmarks/cpp/benchmarks.cpp	/^int main() {$/;"	f	typeref:typename:int
mats	benchmarks/benchmarks.jl	/^const mats = map(n -> rand(MersenneTwister(1), n, n), (5, 16, 32))$/;"	c
mightalias	src/partials.jl	/^Base.mightalias(x::AbstractArray, y::Partials) = false$/;"	f	module:Base
minus_tuple	src/partials.jl	/^@generated function minus_tuple(tup::NTuple{N}) where N$/;"	f
mul_tuples	src/partials.jl	/^@generated function mul_tuples(a::NTuple{N}, b::NTuple{N}, afactor, bfactor) where N$/;"	f
name	benchmarks/benchmarks.jl	/^name(f) = last(split(string(f), '.'))$/;"	f
nextfloat	src/dual.jl	/^function Base.nextfloat(d::ForwardDiff.Dual{T,V,N}) where {T,V,N}$/;"	f	module:Base
no_diag	test/MiscTest.jl	/^    no_diag(X) = [X[i] for i in eachindex(X) if !(i in diagind(X))]$/;"	f
np	benchmarks/py/autograd_benchmarks.py	/^import autograd.numpy as np$/;"	I	nameref:module:autograd.numpy
npartials	src/dual.jl	/^@inline npartials(::Dual{T,V,N}) where {T,V,N} = N$/;"	f
npartials	src/dual.jl	/^@inline npartials(::Type{Dual{T,V,N}}) where {T,V,N} = N$/;"	f
npartials	src/partials.jl	/^@inline npartials(::Partials{N}) where {N} = N$/;"	f
npartials	src/partials.jl	/^@inline npartials(::Type{Partials{N,V}}) where {N,V} = N$/;"	f
one	src/dual.jl	/^@inline Base.one(::Type{Dual{T,V,N}}) where {T,V,N} = Dual{T}(one(V), zero(Partials{N,V}))$/;"	f	module:Base
one	src/dual.jl	/^@inline Base.one(d::Dual) = one(typeof(d))$/;"	f	module:Base
one	src/partials.jl	/^@inline Base.one(::Type{Partials{N,V}}) where {N,V} = Partials{N,V}(one_tuple(NTuple{N,V}))$/;"	f	module:Base
one	src/partials.jl	/^@inline Base.one(partials::Partials) = one(typeof(partials))$/;"	f	module:Base
one_tuple	src/partials.jl	/^@generated function one_tuple(::Type{NTuple{N,V}}) where {N,V}$/;"	f
one_tuple	src/partials.jl	/^@inline one_tuple(::Type{Tuple{}}) = tuple()$/;"	f
operator *	benchmarks/cpp/dual1.cpp	/^Dual1 operator *(const Dual1& x, const Dual1& y) {$/;"	f	typeref:typename:Dual1
operator *	benchmarks/cpp/dual1.cpp	/^Dual1 operator *(double x, const Dual1 &y) {$/;"	f	typeref:typename:Dual1
operator *	benchmarks/cpp/dual2.cpp	/^Dual2 operator *(const Dual2& x, const Dual2& y) {$/;"	f	typeref:typename:Dual2
operator *	benchmarks/cpp/dual2.cpp	/^Dual2 operator *(double x, const Dual2 &y) {$/;"	f	typeref:typename:Dual2
operator *	benchmarks/cpp/dual3.cpp	/^Dual3 operator *(const Dual3& x, const Dual3& y) {$/;"	f	typeref:typename:Dual3
operator *	benchmarks/cpp/dual3.cpp	/^Dual3 operator *(double x, const Dual3 &y) {$/;"	f	typeref:typename:Dual3
operator *	benchmarks/cpp/dual4.cpp	/^Dual4 operator *(const Dual4& x, const Dual4& y) {$/;"	f	typeref:typename:Dual4
operator *	benchmarks/cpp/dual4.cpp	/^Dual4 operator *(double x, const Dual4 &y) {$/;"	f	typeref:typename:Dual4
operator *	benchmarks/cpp/dual5.cpp	/^Dual5 operator *(const Dual5& x, const Dual5& y) {$/;"	f	typeref:typename:Dual5
operator *	benchmarks/cpp/dual5.cpp	/^Dual5 operator *(double x, const Dual5 &y) {$/;"	f	typeref:typename:Dual5
operator +	benchmarks/cpp/dual1.cpp	/^Dual1 operator +(const Dual1& x, const Dual1& y) {$/;"	f	typeref:typename:Dual1
operator +	benchmarks/cpp/dual2.cpp	/^Dual2 operator +(const Dual2& x, const Dual2& y) {$/;"	f	typeref:typename:Dual2
operator +	benchmarks/cpp/dual3.cpp	/^Dual3 operator +(const Dual3& x, const Dual3& y) {$/;"	f	typeref:typename:Dual3
operator +	benchmarks/cpp/dual4.cpp	/^Dual4 operator +(const Dual4& x, const Dual4& y) {$/;"	f	typeref:typename:Dual4
operator +	benchmarks/cpp/dual5.cpp	/^Dual5 operator +(const Dual5& x, const Dual5& y) {$/;"	f	typeref:typename:Dual5
operator -	benchmarks/cpp/dual1.cpp	/^Dual1 operator -(const Dual1& x, const Dual1& y) {$/;"	f	typeref:typename:Dual1
operator -	benchmarks/cpp/dual1.cpp	/^Dual1 operator -(double x, const Dual1 &y) {$/;"	f	typeref:typename:Dual1
operator -	benchmarks/cpp/dual2.cpp	/^Dual2 operator -(const Dual2& x, const Dual2& y) {$/;"	f	typeref:typename:Dual2
operator -	benchmarks/cpp/dual2.cpp	/^Dual2 operator -(double x, const Dual2 &y) {$/;"	f	typeref:typename:Dual2
operator -	benchmarks/cpp/dual3.cpp	/^Dual3 operator -(const Dual3& x, const Dual3& y) {$/;"	f	typeref:typename:Dual3
operator -	benchmarks/cpp/dual3.cpp	/^Dual3 operator -(double x, const Dual3 &y) {$/;"	f	typeref:typename:Dual3
operator -	benchmarks/cpp/dual4.cpp	/^Dual4 operator -(const Dual4& x, const Dual4& y) {$/;"	f	typeref:typename:Dual4
operator -	benchmarks/cpp/dual4.cpp	/^Dual4 operator -(double x, const Dual4 &y) {$/;"	f	typeref:typename:Dual4
operator -	benchmarks/cpp/dual5.cpp	/^Dual5 operator -(const Dual5& x, const Dual5& y) {$/;"	f	typeref:typename:Dual5
operator -	benchmarks/cpp/dual5.cpp	/^Dual5 operator -(double x, const Dual5 &y) {$/;"	f	typeref:typename:Dual5
operator <<	benchmarks/cpp/dual1.cpp	/^std::ostream& operator<<(std::ostream& os, const Dual1& x) {$/;"	f	typeref:typename:std::ostream &
operator <<	benchmarks/cpp/dual2.cpp	/^std::ostream& operator<<(std::ostream& os, const Dual2& x) {$/;"	f	typeref:typename:std::ostream &
operator <<	benchmarks/cpp/dual3.cpp	/^std::ostream& operator<<(std::ostream& os, const Dual3& x) {$/;"	f	typeref:typename:std::ostream &
operator <<	benchmarks/cpp/dual4.cpp	/^std::ostream& operator<<(std::ostream& os, const Dual4& x) {$/;"	f	typeref:typename:std::ostream &
operator <<	benchmarks/cpp/dual5.cpp	/^std::ostream& operator<<(std::ostream& os, const Dual5& x) {$/;"	f	typeref:typename:std::ostream &
order	src/dual.jl	/^@inline order(::Type{Dual{T,V,N}}) where {T,V,N} = 1 + order(V)$/;"	f
order	src/dual.jl	/^@inline order(::Type{V}) where {V} = 0$/;"	f
partials	src/dual.jl	/^    partials::Partials{N,V}$/;"	g	struct:Dual
partials	src/dual.jl	/^@inline Base.@propagate_inbounds partials(::Type{T}, d::Dual{T}, i...) where T = partials(d, i../;"	f
partials	src/dual.jl	/^@inline Base.@propagate_inbounds partials(::Type{T}, x, i...) where T = partials(x, i...)$/;"	f
partials	src/dual.jl	/^@inline Base.@propagate_inbounds partials(d::Dual, i) = d.partials[i]$/;"	f
partials	src/dual.jl	/^@inline Base.@propagate_inbounds partials(d::Dual, i, j) = partials(d, i).partials[j]$/;"	f
partials	src/dual.jl	/^@inline Base.@propagate_inbounds partials(d::Dual, i, j, k...) = partials(partials(d, i, j), k../;"	f
partials	src/dual.jl	/^@inline function partials(::Type{T}, d::Dual{S}, i...) where {T,S}$/;"	f
partials	src/dual.jl	/^@inline partials(d::Dual) = d.partials$/;"	f
partials	src/dual.jl	/^@inline partials(x) = Partials{0,typeof(x)}(tuple())$/;"	f
partials	src/dual.jl	/^@inline partials(x, i...) = zero(x)$/;"	f
partials_wrap	src/jacobian.jl	/^    partials_wrap(ydual, nrange) = partials(T, ydual, nrange)$/;"	f	function:extract_jacobian!
partials_wrap	src/jacobian.jl	/^    partials_wrap(ydual, nrange) = partials(T, ydual, nrange)$/;"	f	function:extract_jacobian_chunk!
pickchunksize	src/prelude.jl	/^function pickchunksize(input_length, threshold = DEFAULT_CHUNK_THRESHOLD)$/;"	f
pow2	test/SIMDTest.jl	/^@inline pow2(x) = x^2$/;"	f	module:SIMDTest
pow2dot	test/SIMDTest.jl	/^pow2dot(xs) = pow2.(xs)$/;"	f	module:SIMDTest
precision	src/dual.jl	/^    Base.precision(::Type{D}) where {D<:Dual} = precision(valtype(D))$/;"	f	module:Base
precision	src/dual.jl	/^    Base.precision(d::Dual) = precision(value(d))$/;"	f	module:Base
precision	src/dual.jl	/^    Base.precision(d::Dual; base::Integer=2) = precision(value(d); base=base)$/;"	f	module:Base
precision	src/dual.jl	/^    function Base.precision(::Type{D}; base::Integer=2) where {D<:Dual}$/;"	f	module:Base
prevfloat	src/dual.jl	/^function Base.prevfloat(d::ForwardDiff.Dual{T,V,N}) where {T,V,N}$/;"	f	module:Base
promote_rule	src/dual.jl	/^            Base.promote_rule(::Type{$R}, ::Type{Dual{T,V,N}}) where {T,V,N} = Dual{T,promote_ty/;"	f	module:Base
promote_rule	src/dual.jl	/^            Base.promote_rule(::Type{Dual{T,V,N}}, ::Type{$R}) where {T,V,N} = Dual{T,promote_ty/;"	f	module:Base
promote_rule	src/dual.jl	/^            Base.promote_rule(::Type{Dual{T,V,N}}, ::Type{R}) where {T,V,N,R<:$R} = Dual{T,promo/;"	f	module:Base
promote_rule	src/dual.jl	/^            Base.promote_rule(::Type{R}, ::Type{Dual{T,V,N}}) where {R<:$R,T,V,N} = Dual{T,promo/;"	f	module:Base
promote_rule	src/dual.jl	/^function Base.promote_rule(::Type{Dual{T,A,N}},$/;"	f	module:Base
promote_rule	src/dual.jl	/^function Base.promote_rule(::Type{Dual{T1,V1,N1}},$/;"	f	module:Base
promote_rule	src/partials.jl	/^Base.promote_rule(::Type{Partials{N,A}}, ::Type{Partials{N,B}}) where {N,A,B} = Partials{N,promo/;"	f	module:Base
qualified_cse!	src/prelude.jl	/^function qualified_cse!(expr)$/;"	f
rand	src/dual.jl	/^@inline Random.rand(::Type{Dual{T,V,N}}) where {T,V,N} = Dual{T}(rand(V), zero(Partials{N,V}))$/;"	f	module:Random
rand	src/dual.jl	/^@inline Random.rand(rng::AbstractRNG, ::Type{Dual{T,V,N}}) where {T,V,N} = Dual{T}(rand(rng, V),/;"	f	module:Random
rand	src/dual.jl	/^@inline Random.rand(rng::AbstractRNG, d::Dual) = rand(rng, value(d))$/;"	f	module:Random
rand	src/partials.jl	/^@inline Random.rand(::Type{Partials{N,V}}) where {N,V} = Partials{N,V}(rand_tuple(NTuple{N,V}))$/;"	f	module:Random
rand	src/partials.jl	/^@inline Random.rand(partials::Partials) = rand(typeof(partials))$/;"	f	module:Random
rand	src/partials.jl	/^@inline Random.rand(rng::AbstractRNG, ::Type{Partials{N,V}}) where {N,V} = Partials{N,V}(rand_tu/;"	f	module:Random
rand	src/partials.jl	/^@inline Random.rand(rng::AbstractRNG, partials::Partials) = rand(rng, typeof(partials))$/;"	f	module:Random
rand_tuple	src/partials.jl	/^@generated function rand_tuple(::Type{NTuple{N,V}}) where {N,V}$/;"	f
rand_tuple	src/partials.jl	/^@generated function rand_tuple(rng::AbstractRNG, ::Type{NTuple{N,V}}) where {N,V}$/;"	f
rand_tuple	src/partials.jl	/^@inline rand_tuple(::AbstractRNG, ::Type{Tuple{}}) = tuple()$/;"	f
rand_tuple	src/partials.jl	/^@inline rand_tuple(::Type{Tuple{}}) = tuple()$/;"	f
randexp	src/dual.jl	/^@inline Random.randexp(::Type{Dual{T,V,N}}) where {T,V,N} = Dual{T}(randexp(V), zero(Partials{N,/;"	f	module:Random
randexp	src/dual.jl	/^@inline Random.randexp(rng::AbstractRNG, ::Type{Dual{T,V,N}}) where {T,V,N} = Dual{T}(randexp(rn/;"	f	module:Random
randn	src/dual.jl	/^@inline Random.randn(::Type{Dual{T,V,N}}) where {T,V,N} = Dual{T}(randn(V), zero(Partials{N,V}))$/;"	f	module:Random
randn	src/dual.jl	/^@inline Random.randn(rng::AbstractRNG, ::Type{Dual{T,V,N}}) where {T,V,N} = Dual{T}(randn(rng, V/;"	f	module:Random
read	src/dual.jl	/^function Base.read(io::IO, ::Type{Dual{T,V,N}}) where {T,V,N}$/;"	f	module:Base
read	src/partials.jl	/^Base.read(io::IO, ::Type{Partials{N,V}}) where {N,V} = Partials{N,V}(ntuple(i->read(io, V), N))$/;"	f	module:Base
real	benchmarks/cpp/benchmarks.h	/^    double real;$/;"	m	class:Dual1	typeref:typename:double
real	benchmarks/cpp/benchmarks.h	/^    double real;$/;"	m	class:Dual2	typeref:typename:double
real	benchmarks/cpp/benchmarks.h	/^    double real;$/;"	m	class:Dual3	typeref:typename:double
real	benchmarks/cpp/benchmarks.h	/^    double real;$/;"	m	class:Dual4	typeref:typename:double
real	benchmarks/cpp/benchmarks.h	/^    double real;$/;"	m	class:Dual5	typeref:typename:double
replace_match!	src/prelude.jl	/^function replace_match!(f, ismatch, lines::AbstractArray)$/;"	f
replace_match!	src/prelude.jl	/^replace_match!(f, ismatch, x) = x$/;"	f
reshape_jacobian	src/jacobian.jl	/^reshape_jacobian(result, ydual, xdual) = reshape(result, length(ydual), length(xdual))$/;"	f
reshape_jacobian	src/jacobian.jl	/^reshape_jacobian(result::DiffResult, ydual, xdual) = reshape_jacobian(DiffResults.jacobian(resul/;"	f
result	src/hessian.jl	/^    result::R$/;"	g	struct:InnerGradientForHess
rosenbrock	benchmarks/cpp/benchmarks.cpp	/^template <typename T> T rosenbrock(const std::vector<T> &x) {$/;"	f	typeref:typename:T
rosenbrock	benchmarks/py/algopy_benchmarks.py	/^def rosenbrock(x):$/;"	f
rosenbrock	benchmarks/py/autograd_benchmarks.py	/^def rosenbrock(x):$/;"	f
round	src/dual.jl	/^Base.round(::Type{R}, d::Dual) where {R<:Real} = round(R, value(d))$/;"	f	module:Base
round	src/dual.jl	/^Base.round(d::Dual) = round(value(d))$/;"	f	module:Base
rtoldefault	src/dual.jl	/^Base.rtoldefault(::Type{D}) where {D<:Dual} = Base.rtoldefault(valtype(D))$/;"	f	module:Base
samerng	test/DualTest.jl	/^samerng() = MersenneTwister(1)$/;"	f
samerng	test/PartialsTest.jl	/^samerng() = MersenneTwister(1)$/;"	f	module:PartialsTest
scale_tuple	src/partials.jl	/^@generated function scale_tuple(tup::NTuple{N}, x) where N$/;"	f
seed!	src/apiutils.jl	/^function seed!(duals::AbstractArray{Dual{T,V,N}}, x, index,$/;"	f
seed!	src/apiutils.jl	/^function seed!(duals::AbstractArray{Dual{T,V,N}}, x,$/;"	f
seeds	src/config.jl	/^    seeds::NTuple{N,Partials{N,V}}$/;"	g	struct:GradientConfig
seeds	src/config.jl	/^    seeds::NTuple{N,Partials{N,V}}$/;"	g	struct:JacobianConfig
self_weighted_logit	benchmarks/py/algopy_benchmarks.py	/^def self_weighted_logit(x):$/;"	f
self_weighted_logit	benchmarks/py/autograd_benchmarks.py	/^def self_weighted_logit(x):$/;"	f
show	src/dual.jl	/^function Base.show(io::IO, d::Dual{T,V,N}) where {T,V,N}$/;"	f	module:Base
show	src/partials.jl	/^Base.show(io::IO, p::Partials{N}) where {N} = print(io, "Partials", p.values)$/;"	f	module:Base
showerror	src/config.jl	/^Base.showerror(io::IO, e::InvalidTagException{E,O}) where {E,O} =$/;"	f	module:Base
showerror	src/dual.jl	/^Base.showerror(io::IO, e::DualMismatchError{A,B}) where {A,B} =$/;"	f	module:Base
simd_sum	test/SIMDTest.jl	/^function simd_sum(x::Vector{T}) where T$/;"	f	module:SIMDTest
sin	benchmarks/cpp/dual1.cpp	/^Dual1 sin(const Dual1& x) {$/;"	f	typeref:typename:Dual1
sin	benchmarks/cpp/dual2.cpp	/^Dual2 sin(const Dual2& x) {$/;"	f	typeref:typename:Dual2
sin	benchmarks/cpp/dual3.cpp	/^Dual3 sin(const Dual3& x) {$/;"	f	typeref:typename:Dual3
sin	benchmarks/cpp/dual4.cpp	/^Dual4 sin(const Dual4& x) {$/;"	f	typeref:typename:Dual4
sin	benchmarks/cpp/dual5.cpp	/^Dual5 sin(const Dual5& x) {$/;"	f	typeref:typename:Dual5
sin	src/dual.jl	/^function Base.sin(d::Dual{T}) where T$/;"	f	module:Base
sincos	src/dual.jl	/^@inline function Base.sincos(d::Dual{T}) where T$/;"	f	module:Base
sincospi	src/dual.jl	/^@inline function Base.sincospi(d::Dual{T}) where T$/;"	f	module:Base
single_seed	src/partials.jl	/^@generated function single_seed(::Type{Partials{N,V}}, ::Val{i}) where {N,V,i}$/;"	f
size	src/partials.jl	/^@inline Base.size(::Partials{N}) where {N} = (N,)$/;"	f	module:Base
sqrt	benchmarks/cpp/dual1.cpp	/^Dual1 sqrt(const Dual1& x) {$/;"	f	typeref:typename:Dual1
sqrt	benchmarks/cpp/dual2.cpp	/^Dual2 sqrt(const Dual2& x) {$/;"	f	typeref:typename:Dual2
sqrt	benchmarks/cpp/dual3.cpp	/^Dual3 sqrt(const Dual3& x) {$/;"	f	typeref:typename:Dual3
sqrt	benchmarks/cpp/dual4.cpp	/^Dual4 sqrt(const Dual4& x) {$/;"	f	typeref:typename:Dual4
sqrt	benchmarks/cpp/dual5.cpp	/^Dual5 sqrt(const Dual5& x) {$/;"	f	typeref:typename:Dual5
static_dual_eval	ext/ForwardDiffStaticArraysExt.jl	/^@inline static_dual_eval(::Type{T}, f::F, x::StaticArray) where {T,F} = f(dualize(T, x))$/;"	f	module:ForwardDiffStaticArraysExt
structural_eachindex	src/apiutils.jl	/^function structural_eachindex(x::AbstractArray, y::AbstractArray)$/;"	f
structural_eachindex	src/apiutils.jl	/^function structural_eachindex(x::Diagonal, y::AbstractArray)$/;"	f
structural_eachindex	src/apiutils.jl	/^function structural_eachindex(x::LowerTriangular, y::AbstractArray)$/;"	f
structural_eachindex	src/apiutils.jl	/^function structural_eachindex(x::UpperTriangular, y::AbstractArray)$/;"	f
structural_eachindex	src/apiutils.jl	/^structural_eachindex(x::AbstractArray) = structural_eachindex(x, x)$/;"	f
structural_length	src/prelude.jl	/^function structural_length(x::Union{LowerTriangular,UpperTriangular})$/;"	f
structural_length	src/prelude.jl	/^structural_length(x::AbstractArray) = length(x)$/;"	f
structural_length	src/prelude.jl	/^structural_length(x::Diagonal) = size(x, 1)$/;"	f
sub_tuples	src/partials.jl	/^@generated function sub_tuples(a::NTuple{N}, b::NTuple{N})  where N$/;"	f
tagcount	src/config.jl	/^@generated function tagcount(::Type{Tag{F,V}}) where {F,V}$/;"	f
tagtype	src/dual.jl	/^@inline tagtype(::Dual{T,V,N}) where {T,V,N} = T$/;"	f
tagtype	src/dual.jl	/^@inline tagtype(::Type{Dual{T,V,N}}) where {T,V,N} = T$/;"	f
tagtype	src/dual.jl	/^@inline tagtype(::Type{V}) where {V} = Nothing$/;"	f
tagtype	src/dual.jl	/^@inline tagtype(::V) where {V} = Nothing$/;"	f
tensor	test/MiscTest.jl	/^function tensor(f, x)$/;"	f	module:MiscTest
testgrad	benchmarks/cpp/benchmarks.cpp	/^void testgrad(){$/;"	f	typeref:typename:void
throw_cannot_dual	src/dual.jl	/^@noinline function throw_cannot_dual(V::Type)$/;"	f
tofloat	src/dual.jl	/^Printf.tofloat(d::Dual) = Printf.tofloat(value(d))$/;"	f	module:Printf
trunc	src/dual.jl	/^Base.trunc(::Type{R}, d::Dual) where {R<:Real} = trunc(R, value(d))$/;"	f	module:Base
trunc	src/dual.jl	/^Base.trunc(d::Dual) = trunc(value(d))$/;"	f	module:Base
tupexpr	src/partials.jl	/^function tupexpr(f, N)$/;"	f
unary_dual_definition	src/dual.jl	/^function unary_dual_definition(M, f)$/;"	f
valtype	src/dual.jl	/^@inline valtype(::Dual{T,V,N}) where {T,V,N} = V$/;"	f
valtype	src/dual.jl	/^@inline valtype(::Type{Dual{T,V,N}}) where {T,V,N} = V$/;"	f
valtype	src/dual.jl	/^@inline valtype(::Type{V}) where {V} = V$/;"	f
valtype	src/dual.jl	/^@inline valtype(::V) where {V} = V$/;"	f
valtype	src/partials.jl	/^@inline valtype(::Partials{N,V}) where {N,V} = V$/;"	f
valtype	src/partials.jl	/^@inline valtype(::Type{Partials{N,V}}) where {N,V} = V$/;"	f
value	src/dual.jl	/^    value::V$/;"	g	struct:Dual
value	src/dual.jl	/^@inline function value(::Type{T}, d::Dual{S}) where {T,S}$/;"	f
value	src/dual.jl	/^@inline value(::Type{T}, d::Dual{T}) where T = value(d)$/;"	f
value	src/dual.jl	/^@inline value(::Type{T}, x) where T = x$/;"	f
value	src/dual.jl	/^@inline value(d::Dual) = d.value$/;"	f
value	src/dual.jl	/^@inline value(x) = x$/;"	f
value_group	benchmarks/benchmarks.jl	/^const value_group = addgroup!(SUITE, "value")$/;"	c
values	src/partials.jl	/^    values::NTuple{N,V}$/;"	g	struct:Partials
vecs	benchmarks/benchmarks.jl	/^const vecs = map(n -> rand(MersenneTwister(1), n), (10, 100, 1000))$/;"	c
vector_mode_dual_eval!	src/apiutils.jl	/^function vector_mode_dual_eval!(f!::F, cfg::JacobianConfig, y, x) where {F}$/;"	f
vector_mode_dual_eval!	src/apiutils.jl	/^function vector_mode_dual_eval!(f::F, cfg::Union{JacobianConfig,GradientConfig}, x) where {F}$/;"	f
vector_mode_gradient	ext/ForwardDiffStaticArraysExt.jl	/^@inline function ForwardDiff.vector_mode_gradient(f::F, x::StaticArray) where {F}$/;"	f	module:ForwardDiff
vector_mode_gradient	src/gradient.jl	/^function vector_mode_gradient(f::F, x, cfg::GradientConfig{T}) where {T, F}$/;"	f
vector_mode_gradient!	ext/ForwardDiffStaticArraysExt.jl	/^@inline function ForwardDiff.vector_mode_gradient!(result, f::F, x::StaticArray) where {F}$/;"	f	module:ForwardDiff
vector_mode_gradient!	src/gradient.jl	/^function vector_mode_gradient!(result, f::F, x, cfg::GradientConfig{T}) where {T, F}$/;"	f
vector_mode_jacobian	ext/ForwardDiffStaticArraysExt.jl	/^@inline function ForwardDiff.vector_mode_jacobian(f::F, x::StaticArray) where {F}$/;"	f	module:ForwardDiff
vector_mode_jacobian	src/jacobian.jl	/^function vector_mode_jacobian(f!::F, y, x, cfg::JacobianConfig{T}) where {F,T}$/;"	f
vector_mode_jacobian	src/jacobian.jl	/^function vector_mode_jacobian(f::F, x, cfg::JacobianConfig{T}) where {F,T}$/;"	f
vector_mode_jacobian!	ext/ForwardDiffStaticArraysExt.jl	/^@inline function ForwardDiff.vector_mode_jacobian!(result, f::F, x::StaticArray) where {F}$/;"	f	module:ForwardDiff
vector_mode_jacobian!	ext/ForwardDiffStaticArraysExt.jl	/^@inline function ForwardDiff.vector_mode_jacobian!(result::ImmutableDiffResult, f::F, x::StaticA/;"	f	module:ForwardDiff
vector_mode_jacobian!	src/jacobian.jl	/^function vector_mode_jacobian!(result, f!::F, y, x, cfg::JacobianConfig{T}) where {F,T}$/;"	f
vector_mode_jacobian!	src/jacobian.jl	/^function vector_mode_jacobian!(result, f::F, x, cfg::JacobianConfig{T}) where {F,T}$/;"	f
withjacobian	test/JacobianTest.jl	/^        function withjacobian(x)$/;"	f	module:JacobianTest
wrapf	benchmarks/py/algopy_benchmarks.py	/^    def wrapf():$/;"	f	function:bench	file:
wrapf	benchmarks/py/autograd_benchmarks.py	/^    def wrapf():$/;"	f	function:bench	file:
write	src/dual.jl	/^function Base.write(io::IO, d::Dual)$/;"	f	module:Base
write	src/partials.jl	/^function Base.write(io::IO, partials::Partials)$/;"	f	module:Base
x	test/DerivativeTest.jl	/^const x = 1$/;"	c	module:DerivativeTest
zero	src/dual.jl	/^@inline Base.zero(::Type{Dual{T,V,N}}) where {T,V,N} = Dual{T}(zero(V), zero(Partials{N,V}))$/;"	f	module:Base
zero	src/dual.jl	/^@inline Base.zero(d::Dual) = zero(typeof(d))$/;"	f	module:Base
zero	src/partials.jl	/^@inline Base.zero(::Type{Partials{N,V}}) where {N,V} = Partials{N,V}(zero_tuple(NTuple{N,V}))$/;"	f	module:Base
zero	src/partials.jl	/^@inline Base.zero(partials::Partials) = zero(typeof(partials))$/;"	f	module:Base
zero_tuple	src/partials.jl	/^@generated function zero_tuple(::Type{NTuple{N,V}}) where {N,V}$/;"	f
zero_tuple	src/partials.jl	/^@inline zero_tuple(::Type{Tuple{}}) = tuple()$/;"	f
∂L∂q̇	test/ConfusionTest.jl	/^∂L∂q̇(L, t, q, q̇) = ForwardDiff.gradient(a->L(t,q,a), q̇)$/;"	f	module:ConfusionTest
≺	src/config.jl	/^@inline function ≺(::Type{Tag{F1,V1}}, ::Type{Tag{F2,V2}}) where {F1,V1,F2,V2}$/;"	f
≺	src/dual.jl	/^≺(a,b) = throw(DualMismatchError(a,b))$/;"	f
